<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter [
<!ENTITY % isopub PUBLIC "ISO 8879:1986//ENTITIES Publishing//EN//XML" "http://www.w3.org/2003/entities/iso8879/isopub.ent">
<!ENTITY % isonum PUBLIC "ISO 8879:1986//ENTITIES Numeric and Special Graphic//EN" "http://www.w3.org/2003/entities/iso8879/isonum.ent">
<!ENTITY % isotech PUBLIC "ISO 8879:1986//ENTITIES General Technical//EN" "http://www.w3.org/2003/entities/iso8879/isotech.ent">
%isopub;%isonum;%isotech;
<!ENTITY % myEnt SYSTEM "teco.ent">
%myEnt;
]>
 <chapter xmlns="http://docbook.org/ns/docbook" version="5.1" xml:id="COM"><title>Command Descriptions</title>
 <para>
 This chapter presents a detailed description of the full TECO
 command set, functionally organized. It assumes that the reader
 is familiar with the elementary TECO commands presented earlier.
 </para><para>
 In the sections following, the letters "m" and "n" are used In
 command formats to represent numerical arguments. These may be
 either simple integers or complex expressions. The letter "q"
 represents any Q-register.
 </para><sect1 xml:id="COM_FSC"><title>File Specification Commands</title>
 <para>
 You must specify an input file whenever you want TECO to accept
 text from any source other than the terminal. You must specify
 an output file whenever you want to make a permanent change to
 the input file. Input and output files are selected by means of
 file specification commands.
 </para><para>
 File specification formats are operating system dependent and are
 fully described in the operating characteristics appendices at
 the end of this manual.
 </para><para>
 Almost every editing job begins with at least one file
 specification command. Additional file specification commands
 may be executed during an editing job whenever required;
 however, TECO will keep only one input file and one output file
 selected at a time.
 </para><para>
 TECO-11 recognizes two input and two output "streams" called the
 primary and secondary streams. The primary input and output
 streams are initially selected when TECO is invoked. Most file
 selection commands, and all of the other TECO commands (page
 manipulation, etc.), operate on the currently selected input
 and/or output stream.
 </para><para>
 The following sections list all of the file specification
 commands. Unless otherwise noted, all of these commands leave
 the text buffer unchanged. Examples of some of these commands
 appear in <xref linkend="BAS"/>.
 </para><sect2 xml:id="COM_FSC_FOC"><title>File Opening Commands</title>
 <para>
 The following commands are used to open files for input and
 output:
 <table xml:id="COM_TAB_FSC_FOC"><title>File Open Commands</title>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Command</para></entry><entry><para>Function</para></entry>
</row>
</thead>
 <tbody>
<row><entry><para>EBfilespec`</para></entry><entry><para>Edit Backup. This command is recommended
 for most editing jobs. It is used for files on
 file-structured devices only. It opens the
 specified file for input on the currently selected
 input stream and for output on the currently
 selected output stream. The EB command also keeps
 the unmodified file (the latest copy of the input
 file) available to the user; details of this
 process are system dependent (See appendices).</para></entry></row>
 <row><entry><para>ERfilespec`</para></entry><entry><para>Edit Read. Opens a file for input on the
 currently selected input stream.</para></entry></row>
 <row><entry><para>EWfilespec`</para></entry><entry><para>Edit Write. Opens a file for output on
 the currently selected output stream.</para></entry></row>
 <row><entry><para>:EBfilespec`</para></entry><entry><para>Executes the EB command, and returns a
 numeric value. -1 returned indicates success: the file
 is open for input. A 0 indicates the specified
 file could not be found, and no error message is
 generated. Other errors (e.g., hardware errors,
 protection violations, etc.) generate messages and
 terminate command execution as usual.</para></entry></row>
 <row><entry><para>:ERfilespec`</para></entry><entry><para>Executes the ER command, and returns a
 numeric value. See the :EB command, above.</para></entry></row>
 
</tbody>
</tgroup></table>
 </para></sect2><sect2 xml:id="COM_FSC_FSS"><title>File Specification Switches</title>
 <para>
 Various system-dependent switches (qualifiers) of the form
 /SWITCH can be used with the file specification in ER, EW, and EB
 commands. These switches are listed below. Consult the
 operating system specific appendices for further details.
 </para><para>
 In addition, on some systems switches are provided for convenient
 handling of BASIC-PLUS or BASIC-PLUS-2 source files which use
 <literal>&lt;LF></literal> or '&amp;' characters for program line continuation. See 
 <xref linkend="APP_BPX"/> for more information.
 <table xml:id="COM_TAB_FSC_FSS"><title>Switches on File Specifications</title>
 <tgroup cols="3" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>
<colspec colname="c3"/>

 <thead>
<row>
<entry><para>System</para></entry><entry><para>Switch</para></entry><entry><para>Meaning</para></entry>
</row>
</thead>
 <tbody>
<row><entry><para>OS/8</para></entry><entry><para>/S</para></entry><entry><para>Ignore end-of-file (<literal>&lt;CTRL/Z></literal>s) on input.
 (SUPER TECO mode)</para></entry></row>
 <row><entry><para/></entry><entry><para/></entry><entry><para/></entry></row>
 <row><entry><para>RSTS/E</para></entry><entry><para>/B</para></entry><entry><para>Read and write with unfiltered 8-bit</para></entry></row>
 <row><entry><para/></entry><entry><para>/n</para></entry><entry><para>Handle BASIC-PLUS-x line continuation</para></entry></row>
 <row><entry><para/></entry><entry><para>/B+</para></entry><entry><para>Handle BASIC-PLUS line continuation</para></entry></row>
 <row><entry><para/></entry><entry><para>/</para></entry><entry><para>Same as /B+</para></entry></row>
 <row><entry><para/></entry><entry><para>/B2</para></entry><entry><para>Handle BASIC-PLUS-x line continuation</para></entry></row>
 <row><entry><para/></entry><entry><para>/CLUSTERSIZE:n</para></entry><entry><para>Specifies output file cluster size</para></entry></row>
 <row><entry><para/></entry><entry><para>/MODE:n</para></entry><entry><para>Use non-standard open mode</para></entry></row>
 <row><entry><para/></entry><entry><para/></entry><entry><para/></entry></row>
 <row><entry><para>VAX/VMS,</para></entry><entry><para>/B2</para></entry><entry><para>Handle BASIC-PLUS-x line continuation</para></entry></row>
 <row><entry><para>RSX-11</para></entry><entry><para>/CR</para></entry><entry><para>Implied carriage control</para></entry></row>
 <row><entry><para/></entry><entry><para>/-CR</para></entry><entry><para>No (internal) carriage control</para></entry></row>
 <row><entry><para/></entry><entry><para>/FT</para></entry><entry><para>FORTRAN carriage control</para></entry></row>
 <row><entry><para/></entry><entry><para>/FTN</para></entry><entry><para>Same as /FT</para></entry></row>
 <row><entry><para/></entry><entry><para>/RW</para></entry><entry><para>Rewind magtape before opening file</para></entry></row>
 <row><entry><para/></entry><entry><para>/SH</para></entry><entry><para>Open the file in shared mode</para></entry></row>
 <row><entry><para/></entry><entry><para>/SHR</para></entry><entry><para>Same as /SH</para></entry></row>
 <row><entry><para/></entry><entry><para>/STM</para></entry><entry><para>Stream format</para></entry></row>
 <row><entry><para/></entry><entry><para>/VAR</para></entry><entry><para>Variable format</para></entry></row>
 <row><entry><para/></entry><entry><para/></entry><entry><para/></entry></row>
 <row><entry><para>TOPS-10</para></entry><entry><para>/APPEND</para></entry><entry><para>Append to existing output file (EW only)</para></entry></row>
 <row><entry><para/></entry><entry><para>/ASCII</para></entry><entry><para>File is ASCII</para></entry></row>
 <row><entry><para/></entry><entry><para>/GENLSN</para></entry><entry><para>Generate line sequence numbers</para></entry></row>
 <row><entry><para/></entry><entry><para>/NOIN</para></entry><entry><para>Don't put user type-in into log file</para></entry></row>
 <row><entry><para/></entry><entry><para>/NONSTD</para></entry><entry><para>Open DECtape in non-standard mode</para></entry></row>
 <row><entry><para/></entry><entry><para>/NOOUT</para></entry><entry><para>Don't put TECO's type-out into log file (EL only)</para></entry></row>
 <row><entry><para/></entry><entry><para>/OCTAL</para></entry><entry><para>Read file in octal</para></entry></row>
 <row><entry><para/></entry><entry><para>/PROTECT:n</para></entry><entry><para>Specify protection code</para></entry></row>
 <row><entry><para/></entry><entry><para>/SIXBIT</para></entry><entry><para>Read file in pure SIXBIT</para></entry></row>
 <row><entry><para/></entry><entry><para>/SUPLSN</para></entry><entry><para>Suppress line sequence numbers</para></entry></row>
 
</tbody>
</tgroup></table>
 </para></sect2><sect2 xml:id="COM_FSC_FCE"><title>File Close and Exit Commands</title>
 <para>
 The following commands are used to close files and exit from TECO:
 <table xml:id="COM_TAB_FSC_FCE"><title>File Close and Exit</title>
 <tgroup cols="3" align="left" colsep="1" rowsep="1">
      <colspec colname="c1"/>
      <colspec colname="c2"/>
      <colspec colname="newCol3"/>
      <thead>
       <row>
        <entry>
         <para>Command</para>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para>Function</para>
        </entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <para>EC</para>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para>Moves the contents of the text buffer, plus the remainder of the current input file
          on the currently selected input stream, to the current output file on the currently
          selected output stream; then closes those input and output files. Control remains in TECO.
          EC leaves the text buffer empty.</para>
        </entry>
       </row>
       <row>
        <entry>
         <para>EF</para>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para>Closes the current output file on the currently selected output stream. The EF
          command does not write the current contents of the buffer to the file before closing
          it.</para>
        </entry>
       </row>
       <row>
        <entry>
         <para>EG`</para>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para>Performs the same function as the EC command, but then exits from TECO and
          re-executes the last COMPIL class command (.COMPILE, .LINK, .EXECUTE, etc.) </para>
         <para>[Same as EX in TECO-11]</para>
        </entry>
       </row>
       <row>
        <entry>
         <para>EGtext`</para>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para>Performs the same function as the EC command, but then exits from TECO and passes
          "text" to the operating system as a command string to be executed (see appendices).</para>
        </entry>
       </row>
       <row>
        <entry morerows="16">
         <para>:EGcmd args`</para>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para>Performs operating system function "cmd" passing that function "args" as arguments.
          This command always returns a value as follows: </para>
        </entry>
       </row>
       <row>
        <entry>
         <para><emphasis role="bold">Value</emphasis></para>
        </entry>
        <entry>
         <para><emphasis role="bold">Meaning</emphasis></para>
        </entry>
       </row>
       <row>
        <entry>
         <para>-1</para>
        </entry>
        <entry>
         <para>Function "cmd" successfully performed.</para>
        </entry>
       </row>
       <row>
        <entry>
         <para>0</para>
        </entry>
        <entry>
         <para>Function "cmd" is unsupported.</para>
        </entry>
       </row>
       <row>
        <entry>
         <para>Other</para>
        </entry>
        <entry>
         <para>Function "cmd" attempted, but failed. The returned value is the failure
          status.</para>
        </entry>
       </row>
       <row>
        <entry namest="c2" nameend="newCol3">
         <para>There are four functions that are commonly defined: </para>
        </entry>
       </row>
       <row>
        <entry>
         <para><emphasis role="bold">cmd</emphasis></para>
        </entry>
        <entry>
         <para><emphasis role="bold">Function</emphasis></para>
        </entry>
       </row>
       <row>
        <entry>
         <para>INI</para>
        </entry>
        <entry>
         <para>Locates the user's private initialization TECO macro.</para>
        </entry>
       </row>
       <row>
        <entry>
         <para>LIB</para>
        </entry>
        <entry>
         <para>Defines the user's private library of TECO macros.</para>
        </entry>
       </row>
       <row>
        <entry>
         <para>MEM</para>
        </entry>
        <entry>
         <para>Read/write TECO's last edited file memory.</para>
        </entry>
       </row>
       <row>
        <entry>
         <para>VTE</para>
        </entry>
        <entry>
         <para>Locates the user's private scope editing TECO macro.</para>
        </entry>
       </row>
       <row>
        <entry namest="c2" nameend="newCol3">
         <para>These four functions work as follows: </para>
        </entry>
       </row>
       <row>
        <entry>
         <para><emphasis role="bold">Command</emphasis></para>
        </entry>
        <entry>
         <para><emphasis role="bold">Function</emphasis></para>
        </entry>
       </row>
       <row>
        <entry>
         <para>:EGcmd`</para>
        </entry>
        <entry>
         <para>Loads Q-register&star; with the requested
          information. If there is no information (e.g., no user private scope editing TECO macro)
          then Q-register&star; is set to the null string.</para>
        </entry>
       </row>
       <row>
        <entry>
         <para>:EGcmd `</para>
        </entry>
        <entry>
         <para>Clears the information holder. Subsequent :EGcmd` commands will set Q-register
         &star; to the null string.</para>
        </entry>
       </row>
       <row>
        <entry>
         <para>:EGcmd text`</para>
        </entry>
        <entry>
         <para>Sets the information holder to "text". Subsequent :EGcmd` commands will set
          Q-register&star; to "text".</para>
        </entry>
       </row>
       <row>
        <entry namest="c2" nameend="newCol3">
         <para>Consult the appendices for details.</para>
        </entry>
       </row>
       <row>
        <entry>
         <para>EK</para>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para>Kill the current output file on the currently selected output stream. This command,
          which purges the output file without closing it, is useful to abort an undesired edit.
          Executing the EK command after an EW which is superseding an existing file leaves the old
          file intact. The EK command also "undoes" an EB command. (See appendices for
          details.)</para>
        </entry>
       </row>
       <row>
        <entry>
         <para>ELfilespec`</para>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para> Open the specified file for output as a log file. Any currently open log file will
          be closed. If the /APPEND switch is given, future logs will append to the file (if it
          already exists). The default is to supersede. All type-in to TECO and all type-out from
          TECO goes into the log file. The log file is automatically closed by the EX and
           <literal>&lt;CTRL/C></literal><literal>&lt;CTRL/C></literal> TECO commands. [TECO-10
          only]</para>
        </entry>
       </row>
       <row>
        <entry>
         <para>EX</para>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para>Performs the same function as the EC command, but then exits from TECO. For safety
          reasons, this command is aborted if there is text in the text buffer but no output file is
          open. To exit TECO after just looking at a file, use the command string HKEX.</para>
        </entry>
       </row>
       <row>
        <entry>
         <para>EZfilespec`</para>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para> This command is useful for outputting to magtapes and DECtapes, on which it
          initializes (zeros) the specified output device before switching the ouput to the primary
          output stream. In the case of a magtape, this command rewinds the magtape to load point.
          If the output device is a disk, this command works exactly like the EW command. [TECO-10
          only]</para>
        </entry>
       </row>
       <row>
        <entry>
         <para><literal>&lt;CTRL/C></literal></para>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para> The <literal>&lt;CTRL/C></literal> (caret/C) command terminates execution of the
          current command string and returns control to TECO's prompt. (Under TECO-8, the
           <literal>&lt;CTRL/C></literal> command currently acts as
           <literal>&lt;CTRL/C></literal><literal>&lt;CTRL/C></literal>.)</para>
        </entry>
       </row>
       <row>
        <entry>
         <para><literal>&lt;CTRL/C></literal>
          <literal>&lt;CTRL/C></literal></para>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para> The ^C<literal>&lt;CTRL/C></literal> command causes an immediate abort and exit from
          TECO. Currently open files are not necessarily closed. See the appendices for more
          details. Note that the second <literal>&lt;CTRL/C></literal> may not be entered in
          up-arrow mode.</para>
        </entry>
       </row>
      </tbody>
     </tgroup></table>
 </para></sect2><sect2 xml:id="COM_FSC_SSC"><title>Secondary Stream Commands</title>
 <para>
 TECO-11 provides secondary input and output streams. These
 permit the user to have two input and two output files open at
 the same time, and to switch processing back and forth between
 them. Each stream maintains its file position independently, so
 that one can read from one stream (for example), switch to the
 other, and then switch back to the first and resume from where
 one left off. In addition, a separate command stream allows one
 to execute TECO commands from a file without disturbing either
 input stream.
 </para><para>
 The following commands manipulate the secondary input and output
 streams:
 <table xml:id="COM_TAB_FSC_SSC"><title>Secondary Stream Commands</title>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Command</para></entry><entry><para>Function</para></entry>
</row>
</thead>
 <!-- <table_unit> -->
 <tbody>
<row><entry namest="c1" nameend="c2" align="left"><para>Input commands</para></entry></row>
 <row><entry><para>EP</para></entry><entry><para>Switches the input to the secondary input stream.</para></entry></row>
 <row><entry><para>ER`</para></entry><entry><para>Switches the input to the primary input stream.</para></entry></row>
 <!-- <endtable_unit> -->
 <!-- <table_unit> -->
 <row><entry namest="c1" nameend="c2" align="left"><para>Output commands</para></entry></row>
 <row><entry><para>EA</para></entry><entry><para>Switches the output to the secondary output stream.</para></entry></row>
 <row><entry><para>EW`</para></entry><entry><para>
 Switches the output to the primary output stream.</para></entry></row>
 <!-- <endtable_unit> -->
 <!-- <table_unit> -->
 <row><entry namest="c1" nameend="c2" align="left"><para>Indirect file commands</para></entry></row>
 <row><entry><para>EIfilespec`</para></entry><entry><para>
 Opens a file as an indirect command file, so that
 any further TECO requests for terminal input will
 come from this file. At end-of-file, or upon
 TECO's receipt of any error message, the indirect
 command file will be closed and terminal input
 will be switched back to the terminal. Note that
 this command only presets where input will come
 from; it does not "splice" the file's data into
 the current command string.</para></entry></row>
 <row><entry><para/></entry><entry><para> While end-of-file closes the indirect command file, it does not automatically start execution
          of commands. Execution will begin only upon TECO's receipt of two adjacent
           <literal>&lt;ESC></literal>s. For instance, assume that FOO.TEC contains valid TECO
          commands, that it presets a return to your terminal with the customary EI`, but that it
          does not contain an <literal>&lt;ESC></literal><literal>&lt;ESC></literal> pair. If you
          type EIFOO``, TECO will read in the contents of FOO.TEC (building a command string) and
          attempt to continue building the command string by reading from your terminal when end of
          file on FOO.TEC is encountered. Things will appear "very quiet" until it occurs to you to
          type <literal>&lt;DELIM></literal><literal>&lt;DELIM></literal> and so begin execution of
          the (composite) command string.</para></entry></row>
 <row><entry><para/></entry><entry><para> All commands encountered in the indirect file will have their normal TECO meaning (as opposed
          to any immediate action meaning). For example, a <literal>&lt;CTRL/U></literal>
          encountered in an indirect file will not erase the command line in which it occurs.
          Instead, it will be treated as the TECO ^Uqtext` command. The only exception to this rule
          is the <literal>&lt;ESC></literal><literal>&lt;ESC></literal> command, which directs TECO
          to execute the preceding command string and then return to the indirect file at the point
          following the <literal>&lt;ESC></literal><literal>&lt;ESC></literal>. (We can say
           <literal>&lt;ESC></literal> explicitly here, because <literal>&lt;DELIM></literal> can be
          other than ESCape only in commands typed at the terminal.)</para></entry></row>
 <row><entry><para>EI`</para></entry><entry><para>If an indirect command file is active, this
 command will close it and resume terminal input
 from the terminal. Any portion of the file after
 a double <literal>&lt;DELIM></literal> which has not yet been read is
 discarded. This command has no effect if no
 indirect file is already open.</para></entry></row>
 <!-- <endtable_unit> -->
 
</tbody>
</tgroup></table>
 </para></sect2><sect2 xml:id="COM_FSC_WCC"><title>Wildcard Commands</title>
 <para>
 TECO-11 supports wild card file processing with a set of special
 commands, to allow TECO programs to operate on a set of files.
 [Not in TECO-8 or TECO-10]
 <table xml:id="COM_TAB_FSC_WCC"><title>Wildcard Commands</title>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Command</para></entry><entry><para>Function</para></entry>
</row>
</thead>
 <tbody>
<row><entry><para>ENfilespec`</para></entry><entry><para>
 This command presets the "wild card" lookup
 filespec. It is only a preset; it does not open,
 close, or try to find any file. The "wild card"
 lookup is the only filespec that can contain any
 wild card notations. See the appendices for the
 allowed wild fields in each operating system.</para></entry></row>
 <row><entry><para>EN`</para></entry><entry><para>Once the wild card lookup filespec has been
 preset, executing this command will find the next
 file that matches the preset wild card lookup
 filespec and will load the filespec buffer with
 that file's name. The G&star; command (see <xref linkend="APP_INC"/>,
 section C.1.1) can be used to retrieve the fully
 expanded filespec. When no more occurences of the
 wild card filespec exist, the ?FNF error is
 returned.</para></entry></row>
 <row><entry><para>:EN`</para></entry><entry><para> Executes the EN` command, and returns a numeric value. A -1 indicates that another match of
          the wild card filespec exists and has been loaded into the filespec buffer. A 0 indicates
          no more occurences exist. No error message is generated.</para></entry></row>
 
</tbody>
</tgroup></table>
 </para><para>
 The filespec argument to the file selection commands in TECO-11
 can use the string building characters described in <xref linkend="COM_TAB_SBC"/>
 (see <xref linkend="COM_SRA"/>). The <literal>&lt;CTRL/E></literal>Q&star; construct, described in
 <xref linkend="APP_INC"/>, is especially useful in TECO-11.
 </para></sect2><sect2 xml:id="COM_FSC_IOQ"><title>Direct I/O to Q-Registers</title>
 <para>
 TECO-10 provides commands to do I/O directly to and from the
 Q-registers, allowing I/O to bypass the text buffer.
 [Not in TECO-8 or TECO-11]
 <table xml:id="COM_TAB_FSC_IOQ"><title>Direct I/O to Q-registers</title>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Command</para></entry><entry><para>Function</para></entry>
</row>
</thead>
 <tbody>
<row><entry><para>EQqfilespec`</para></entry><entry><para>
 Read specified file into Q-register q. No <literal>&lt;NULL></literal>s
 or <literal>&lt;FF></literal>s are removed from the file, except that
 trailing <literal>&lt;NULL></literal>s are discarded. The only switch
 permitted on the filespec in this command is the
 /DELETE switch, which causes TECO to delete the
 file after reading it, providing that the file is
 less than 500 characters long. This command
 supports the pseudo-device TMP:, for TMPCOR.
 Consult the appropriate appendix for details.
 [TECO-10 only]</para></entry></row>
 <row><entry><para>E%qfilespec`</para></entry><entry><para>
 Create the specified file. The contents of the
 file will be the contents of Q-register q with no
 <literal>&lt;NULL></literal>s deleted. No switches are permitted on the
 filespec of this command. This command supports
 the pseudo-device TMP:, for TMPCOR. Consult the
 appropriate appendix for details.
 [TECO-10 only]</para></entry></row>
 
</tbody>
</tgroup></table>
 </para></sect2></sect1><sect1 xml:id="COM_PMC"><title>Page Manipulation Commands</title>
 <para>
 The following commands permit text to be read into the text
 buffer from an input file or written from the buffer onto an
 output file.
 </para><para>
 All of the input commands listed in this table assume that the
 input file is organized into pages small enough to fit into
 available memory. If any page of the input file contains more
 characters than will fit into available memory, the input command
 will continue reading characters into the buffer until a line
 feed is encountered when the buffer is about 3/4 full. See the
 appendices for more details. Special techniques for handling
 pages larger than the buffer capacity will be presented later in
 this chapter.
 <table xml:id="COM_TAB_PMC"><title>Page Manipulation Commands</title>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Command</para></entry><entry><para>Function</para></entry>
</row>
</thead>
 <!-- <table_unit> -->
 <tbody>
<row><entry namest="c1" nameend="c2" align="left"><para>APPEND commands</para></entry></row>
 <row><entry><para>A</para></entry><entry><para>Appends the next page of the input file to the contents
 of the text buffer, thus combining the two pages of
 text on a single page with no intervening form feed
 character. This command takes no argument. To perform
 n Appends, use the n<literal>&lt;A></literal> construct. Note that nA is a
 completely different command.</para></entry></row>
 <row><entry><para>:A</para></entry><entry><para>Equivalent to the A command except that a value is
 returned. -1 is returned if the append succeeded, and
 0 is returned if the append failed because the
 end-of-the-input-file had previously been reached (^N
 flag is -1 at start of this command).
 [Not in TECO-8]</para></entry></row>
 <row><entry><para>n:A</para></entry><entry><para>Appends n lines of text from the input file to the
 contents of the text buffer. The value of n must not
 be negative. A value is returned indicating whether or
 not there were in fact n lines remaining in the input
 file. -1 is returned if the command succeeded. 0 is
 returned if end-of-file on the input file was
 encountered before all n lines were read in. Note that
 the command can succeed and yet read in fewer than n
 lines in the case that the text buffer fills up.
 [Not in TECO-8]</para></entry></row>
 <!-- <endtable_unit> -->
 <!-- <table_unit> -->
 <row><entry namest="c1" nameend="c2" align="left"><para>PAGE Commands</para></entry></row>
 <row><entry><para>P</para></entry><entry><para>Writes the contents of the buffer onto the output file,
 then clears the buffer and reads the next page of the
 input file into the buffer. A form feed is appended to
 the output file if the last page read in (with a P, Y,
 or A command) was terminated with a form feed.</para></entry></row>
 <row><entry><para>:P</para></entry><entry><para>Same as the P command except that a value is returned.
 -1 is returned if the command succeeded. 0 is returned
 if the command failed because the end-of-file on the
 input file had been reached prior to the initiation of
 this command. The command string <literal>&lt;:P;></literal> takes you to
 end of file.
 [Not in TECO-8]</para></entry></row>
 <row><entry><para>nP</para></entry><entry><para>Executes the P command n times, where n must be a
 non-zero positive integer.
 In TECO-32 n can be a negative integer (and
 -P means -1P). A -nP command will back up n pages.</para></entry></row>
 <row><entry><para>n:P</para></entry><entry><para>Executes the :P command n times, where n must be a
 non-zero positive integer. In TECO-32 n
 can be a negative integer (and -:P means -1:P). This
 command returns 0 when another page could not be backed
 up because beginning of file had been reached.
 [Not in TECO-8]</para></entry></row>
 <row><entry><para>PW</para></entry><entry><para>Write the contents of the buffer onto the output file
 and append a form feed character. The buffer is not
 cleared and the pointer position remains unchanged.</para></entry></row>
 <row><entry><para>nPW</para></entry><entry><para>Executes the PW command n times, where n must be a
 non-zero positive integer.</para></entry></row>
 <row><entry><para>m,nPW</para></entry><entry><para>Writes the contents of the buffer between pointer
 positions m and n onto the output file. m and n must
 be positive integers. A form feed is not appended to
 this output, nor is the buffer cleared. The pointer
 position remains unchanged.</para></entry></row>
 <row><entry><para>m,nP</para></entry><entry><para>Equivalent to m,nPW.</para></entry></row>
 <row><entry><para>HPW</para></entry><entry><para>Equivalent to the PW command except that a form feed
 character is not appended to the output.</para></entry></row>
 <row><entry><para>HP</para></entry><entry><para>Equivalent to HPW.</para></entry></row>
 <!-- <endtable_unit> -->
 <!-- <table_unit> -->
 <row><entry namest="c1" nameend="c2" align="left"><para>YANK commands</para></entry></row>
 <row><entry><para>Y</para></entry><entry><para>Clears the text buffer and then reads the next page of
 the input file into the buffer. Because the Y command
 DESTROYS the current text buffer, its use can result in
 the loss of data, and is subject to "Yank protection"
 (see ED flag in <xref linkend="COM_CEC"/>.)</para></entry></row>
 <row><entry><para>-Y</para></entry><entry><para>Clears the text buffer and then reads the previous page
 of the file being edited back into the buffer. Because
 the Y command DESTROYS the current text buffer, its use
 can result in the loss of data, and is subject to "Yank
 protection" (see ED flag in <xref linkend="COM_CEC"/>).
 [TECO-11 on VAX/VMS only]</para></entry></row>
 <row><entry><para>:Y</para></entry><entry><para>Same as the Y command but a value is returned. -1 is
 returned if the Yank succeeded. 0 is returned if the
 Yank failed because the end-of-file had been reached on
 the input file prior to the initiation of this command.
 [Not in TECO-8]</para></entry></row>
 <row><entry><para>-:Y</para></entry><entry><para>Same as the -Y command but a value is returned. -1 is
 returned if the Yank succeeded. 0 is returned if the
 Yank failed because the beginning of file had been
 reached on the file being edited prior to the
 initiation of this command.
 [TECO-32 only]</para></entry></row>
 <row><entry><para>EY</para></entry><entry><para>Same as the Y command, but its action is always
 permitted regardless of the value of the Yank
 Protection bit in the ED flag. Remember that Yank
 DESTROYS the current buffer; there's no way to get it back!</para></entry></row>
 <row><entry><para>:EY</para></entry><entry><para>Same as the :Y command, but its action is always
 permitted regardless of the value of the Yank
 protection bit in the ED flag. Remember that Yank
 DESTROYS the current buffer; there's no way to get it back!
 [Not in TECO-8]</para></entry></row>
 <!-- <endtable_unit> -->
 
</tbody>
</tgroup></table>
 </para></sect1><sect1 xml:id="COM_BPC"><title>Buffer Pointer Manipulation Commands</title>
 <para>
 <xref linkend="COM_TAB_BPC"/> describes all of the buffer pointer manipulation
 commands These commands may be used to move the pointer to a
 position between any two characters in the buffer, but they will
 not move the pointer across a buffer boundary. If any R or C
 command attempts to move the pointer backward beyond the
 beginning of the buffer or forward past the end of the buffer,
 the command is ignored and an error message is printed. If any L
 command attempts to exceed the buffer boundaries, the pointer is
 positioned at the boundary which would have been exceeded and no
 error message is printed.
 <table xml:id="COM_TAB_BPC"><title>Buffer Pointer Manipulation Commands</title>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Command</para></entry><entry><para>Function</para></entry>
</row>
</thead>
 <!-- <table_unit> -->
 <tbody>
<row><entry namest="c1" nameend="c2" align="left"><para>CHARACTER commands</para></entry></row>
 <row><entry><para>C</para></entry><entry><para>Advances the pointer forward across one character.</para></entry></row>
 <row><entry><para>nC</para></entry><entry><para>Executes the C command n times. If n is positive, the
 pointer is moved forward across n characters. If n is
 negative, the pointer is moved backward across n
 characters. If n is zero, the pointer position is not
 changed.</para></entry></row>
 <row><entry><para>n:C</para></entry><entry><para>Same as nC except that a value is returned. If the
 command succeeded, -1 is returned. If the command
 failed, the pointer does not move and a value of 0 is
 returned.
 [TECO-10 only]</para></entry></row>
 <row><entry><para>:C</para></entry><entry><para>Equivalent to 1:C.</para></entry></row>
 <row><entry><para>-C</para></entry><entry><para>Equivalent to -1C.</para></entry></row>
 <!-- <endtable_unit> -->
 <!-- <table_unit> -->
 <row><entry namest="c1" nameend="c2" align="left"><para>JUMP commands</para></entry></row>
 <row><entry><para>J</para></entry><entry><para>Moves the pointer to a position immediately preceding
 the first character in the buffer. Equivalent to 0J.</para></entry></row>
 <row><entry><para>nJ</para></entry><entry><para>Moves the pointer to a position immediately following
 the nth character in the buffer.</para></entry></row>
 <row><entry><para>ZJ</para></entry><entry><para>Moves the pointer to a position immediately following
 the last character in the buffer.</para></entry></row>
 <row><entry><para>n:J</para></entry><entry><para>Same as the nJ command except that if pointer position
 n is outside of the buffer, the pointer does not move
 and a value of 0 is returned. If the command
 succeeded, a value of -1 is returned.
 [TECO-10 only]</para></entry></row>
 <!-- <endtable_unit> -->
 <!-- <table_unit> -->
 <row><entry namest="c1" nameend="c2" align="left"><para>LINE commands</para></entry></row>
 <row><entry><para>L</para></entry><entry><para>Advances the pointer forward across the next line
 terminator (line feed, vertical tab, or form feed) and
 positions it at the beginning of the next line.</para></entry></row>
 <row><entry><para>nL</para></entry><entry><para>Executes the L command n times. A positive value of n
 advances the pointer to the beginning of the nth line
 following its current position. A negative value of n
 moves the pointer backwards to the beginning of the nth
 complete line preceding its current position. If n is
 zero, the pointer is moved to the beginning of the line
 on which it is currently positioned.</para></entry></row>
 <row><entry><para>-L</para></entry><entry><para>Equivalent to -1L.</para></entry></row>
 <!-- <endtable_unit> -->
 <!-- <table_unit> -->
 <row><entry namest="c1" nameend="c2" align="left"><para>REVERSE commands</para></entry></row>
 <row><entry><para>R</para></entry><entry><para>Moves the pointer backward across one character.</para></entry></row>
 <row><entry><para>nR</para></entry><entry><para>Executes the R command n times. If n is positive, the
 pointer is moved backward across n characters. If n is
 negative, the pointer is moved forward across n
 characters. If n is zero, the position of the pointer
 is not changed.</para></entry></row>
 <row><entry><para>-R</para></entry><entry><para>Equivalent to -1R.</para></entry></row>
 <row><entry><para>n:R</para></entry><entry><para>Same as the nR command except that a value is returned.
 If the command succeeded, then a value of -1 is
 returned. If the command failed, then the buffer
 pointer is not moved and a value of 0 is returned.
 [TECO-10 only]</para></entry></row>
 <row><entry><para>:R</para></entry><entry><para>Equivalent to 1:R.</para></entry></row>
 <!-- <endtable_unit> -->
 
</tbody>
</tgroup></table>
 </para></sect1><sect1 xml:id="COM_TTO"><title>Text Type-Out Commands</title>
 <para>
 <xref linkend="COM_TAB_TTO"/> describes the commands used to type
 out part or all of
 the contents of the buffer for examination. These commands do
 not move the buffer pointer.
 <table xml:id="COM_TAB_TTO"><title>Text Type-Out Commands</title>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Command</para></entry><entry><para>Function</para></entry>
</row>
</thead>
 <tbody>
<row><entry><para>T</para></entry><entry><para>Types out the contents of the buffer from the current
 position of the buffer pointer through and including
 the next line terminator character.</para></entry></row>
 <row><entry><para>nT</para></entry><entry><para>Types n lines. If n is positive, types the n lines
 following the current position of the pointer. If n is
 negative, types the n lines preceding the pointer. If
 n is zero, types the contents of the buffer from the
 beginning of the line on which the pointer is located
 up to the pointer.</para></entry></row>
 <row><entry><para>-T</para></entry><entry><para>Equivalent to -1T.</para></entry></row>
 <row><entry><para>m,nT</para></entry><entry><para>Types out the contents of the buffer between pointer
 positions m and n.</para></entry></row>
 <row><entry><para>.,.+nT</para></entry><entry><para>Types out the n characters immediately following the
 buffer pointer. n should be greater than zero.</para></entry></row>
 <row><entry><para>.-n,.T</para></entry><entry><para>Types the n characters immediately preceding the buffer
 pointer. n should be greater than zero.</para></entry></row>
 <row><entry><para>n^T</para></entry><entry><para>Types out to the terminal the character whose ASCII
 value is n. Whatever normal type-out conversions may
 currently be in effect and applicable (such as
 translation of control characters to up-arrow format)
 are done. The value of n is used modulo 256.</para></entry></row>
 <row><entry><para>n:^T</para></entry><entry><para>Outputs to the terminal the character whose ASCII value
 is n. Output is done in "one-shot" binary mode; no
 type-out translations are done. The value of n is used
 modulo 256.
 [TECO-11 only]</para></entry></row>
 <row><entry><para>HT</para></entry><entry><para>Types out the entire contents of the buffer.</para></entry></row>
 <row><entry><para>V</para></entry><entry><para>Types out the current line. Equivalent to 0TT.</para></entry></row>
 <row><entry><para>nV</para></entry><entry><para>Types out n-1 lines on each side of the current line.
 Equivalent to 1-nTnT.
 [Not in TECO-8]</para></entry></row>
 <row><entry><para>m,nV</para></entry><entry><para>Types out m-1 lines before and n-1 lines after the
 current line.
 [Not in TECO-8]</para></entry></row>
 <row><entry><para>^Atext<literal>&lt;CTRL/A></literal></para></entry><entry><para>
 Types"text" on the terminal. While the command may
 begin with <literal>&lt;CTRL/A></literal> or Caret/A, the closing character
 must be a <literal>&lt;CTRL/A></literal>. A numeric argument must not be
 specified with this command.</para></entry></row>
 <row><entry><para>@^A/text/</para></entry><entry><para>Equivalent to the ^A command except that the text to be
 printed may be bracketed with any character. This
 avoids the need for the closing <literal>&lt;CTRL/A></literal>.</para></entry></row>
 
</tbody>
</tgroup></table>
 </para><para>
 You may stop or delay the output of any type-out command by
 typing certain special characters at the keyboard while TECO is
 typing out at the terminal (via a T, V, ^A, or :G command).
 These characters are described in the table below:
 <table xml:id="COM_TAB_TOT"><title>Type-Out Time Commands</title>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Character</para></entry><entry><para>Function</para></entry>
</row>
</thead>
 <tbody>
<row><entry><para><literal>&lt;CTRL/O></literal></para></entry><entry><para>
 Stops the terminal output of the current command
 string. TECO continues to run and to send
 characters to the terminal, however, these
 characters are suppressed from actually printing on
 the terminal. You can resume printing characters by
 typing another <literal>&lt;CTRL/O></literal> while type-out is being
 suppressed. TECO cancels this suppression the next
 time that it prompts for command string input. A
 TECO macro can cancel the effect of any <literal>&lt;CTRL/O></literal> by
 setting the 16's bit in the ET flag (see <xref linkend="COM_MCF"/>).</para></entry></row>
 <row><entry><para><literal>&lt;CTRL/S></literal></para></entry><entry><para>
 Freezes the terminal output of the current command
 string. TECO stops running the next time it tries
 to output a character to your terminal, and waits
 for you to type a <literal>&lt;CTRL/Q></literal> to indicate that output
 should resume.</para></entry></row>
 <row><entry><para><literal>&lt;CTRL/Q></literal></para></entry><entry><para>
 Causes TECO to resume any type-out that was frozen
 via use of the <literal>&lt;CTRL/S></literal> command described above.
 This character has this effect only while typout is
 frozen. Striking any key other than <literal>&lt;CTRL/Q></literal> or
 <literal>&lt;CTRL/C></literal> while type-out is frozen will have
 unpredictable results; consult the appropriate
 operating system manual.</para></entry></row>
 
</tbody>
</tgroup></table>
 </para><para>
 Note that <literal>&lt;CTRL/O></literal>, <literal>&lt;CTRL/Q></literal>, and
 <literal>&lt;CTRL/S></literal> are legal TECO
 commands as well. When TECO is not typing on the terminal (when
 you are entering a command string, for example), these characters
 do not have the effect described above. They may be entered into
 your command string just like any other control character (except
 under operating systems that filter out these characters, see 
 <xref linkend="CSE_OSCF"/>).
 </para></sect1><sect1 xml:id="COM_DEL"><title>Deletion Commands</title>
 <para>
 <xref linkend="COM_TAB_DEL"/> summarizes the text deletion commands, which permit
 deletion of single characters, groups of adjacent characters,
 single lines, or groups of adjacent lines.
 <table xml:id="COM_TAB_DEL"><title>Text Deletion Commands</title>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Command</para></entry><entry><para>Function</para></entry>
</row>
</thead>
 <!-- <table_unit> -->
 <tbody>
<row><entry namest="c1" nameend="c2" align="left"><para>DELETE commands</para></entry></row>
 <row><entry><para>D</para></entry><entry><para>Delete the first character following the current
 position of the buffer pointer.</para></entry></row>
 <row><entry><para>nD</para></entry><entry><para>Execute the D command n times. If n is positive, the n
 characters following the current pointer position are
 deleted. If n is negative, the n characters preceding
 the current pointer position are deleted. If n is
 zero, the command is ignored.</para></entry></row>
 <row><entry><para>-D</para></entry><entry><para>Equivalent to -1D.</para></entry></row>
 <row><entry><para>m,nD</para></entry><entry><para>Equivalent to m,nK.
 [TECO-11 only]</para></entry></row>
 <row><entry><para>n:D</para></entry><entry><para>Same as nD but returns a value (-1 if command succeeds,
 0 if command failed because the range of characters to
 be deleted fell outside the text buffer).
 [TECO-10 only]</para></entry></row>
 <row><entry><para>FDtext`</para></entry><entry><para>
 Search for the specified text string and delete it.
 (See search commands in <xref linkend="COM_SRC"/>.)
 [TECO-10 only]</para></entry></row>
 <row><entry><para>@FD/text/</para></entry><entry><para>Equivalent to FDtext` except that the <literal>&lt;DELIM></literal> character is not
         necessary.</para></entry></row>
 <row><entry><para>FR`</para></entry><entry><para> Equivalent to -nD where n is the length of the last insert, get or search command. See the
         description of the FRtext` command in <xref linkend="COM_INS"/> for more details.</para></entry></row>
 <row><entry><para>@FR//</para></entry><entry><para> Form of the FR` command that does not require use of the <literal>&lt;DELIM></literal>
         character.</para></entry></row>
 <!-- <endtable_unit> -->
 <!-- <table_unit> -->
 <row><entry namest="c1" nameend="c2" align="left"><para>KILL commands</para></entry></row>
 <row><entry><para>K</para></entry><entry><para>Deletes the contents of the buffer from the current
 position of the buffer pointer through and including
 the next line terminator character.</para></entry></row>
 <row><entry><para>nK</para></entry><entry><para>Executes the K command n times. If n is positive, the
 n lines following the current pointer position are
 deleted. If n is negative, the n lines preceding the
 current pointer position are deleted. If n is zero,
 the contents of the buffer from the beginning of the
 line on which the pointer is located up to the pointer
 is deleted. It is not an error if more lines are
 specified than occur when a boundary of the text buffer
 is encountered.</para></entry></row>
 <row><entry><para>-K</para></entry><entry><para>Equivalent to -1K.</para></entry></row>
 <row><entry><para>m,nK</para></entry><entry><para>Deletes the contents of the buffer between pointer
 positions m and n. The pointer moves to the point of
 the deletion. The ?POP error message (or its
 equivalent) is issued if either m or n is out of range.</para></entry></row>
 <row><entry><para>FKtext`</para></entry><entry><para> Executes a Stext` command then deletes all the text from the initial pointer position to the
         new pointer position. [TECO-10 only]</para></entry></row>
 <row><entry><para>@FK/text/</para></entry><entry><para> Equivalent to FKtext` except that "text" may contain any character, including
          <literal>&lt;ESCAPE></literal>, other than the delimiter (shown here as /). [TECO-10
         only]</para></entry></row>
 <row><entry><para>HK</para></entry><entry><para>Deletes the entire contents of the buffer.</para></entry></row>
 <!-- <endtable_unit> -->
 
</tbody>
</tgroup></table>
 </para></sect1><sect1 xml:id="COM_INS"><title>Insertion Commands</title>
 <para>
 <xref linkend="COM_TAB_INS"/> lists all of the text insertion commands. These
 commands cause the string of characters specified in the command
 to be inserted into the text buffer at the current position of
 the buffer pointer. Following execution of an insertion command,
 the pointer will be positioned immediately after the last
 character of the insertion.
 </para><para>
 The length of an insertion command is limited primarily by the
 amount of memory available for command string storage. During
 normal editing jobs, it is most convenient to limit insertions to
 about 10 or 15 lines each. When command string space is about to
 run out, TECO will ring the terminal's bell after each character
 that is typed. From the time you hear the first warning bell,
 you have 10 characters to type in order to clean up your command
 line. Attempting to enter too many characters into the current
 command string causes unpredictible results to occur and should
 be avoided. Use the DELETE key to shorten the command to permit
 its termination.
 </para><para> As explained above in <xref linkend="CSE"/>, certain characters are filtered out by the
   operating system and/or may perform special functions, and some characters are immediate action
   commands and have special effect. If you want to insert such characters into the text buffer, use
   the nI` command described in the following table. It will insert any ASCII character into the
   buffer, including the special characters that could not ordinarily be typed at a terminal. <table
    xml:id="COM_TAB_INS">
    <title>Text Insertion Commands</title>
    <tgroup cols="2" align="left" colsep="1" rowsep="1">
     <colspec colname="c1"/>
     <colspec colname="c2"/>
     <thead>
      <row>
       <entry>
        <para>Command</para>
       </entry>
       <entry>
        <para>Function</para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>Itext`</para>
       </entry>
       <entry>
        <para> Where "text" is a string of ASCII characters terminated by a
          <literal>&lt;DELIM></literal>. The specified text string is entered into the buffer at the
         current position of the pointer, with the pointer positioned immediately after the last
         character of the insertion.</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>nI`</para>
       </entry>
       <entry>
        <para> This form of the I command inserts the single character whose ASCII code is n into
         the buffer at the current position of the buffer pointer. (n is taken modulo 256 in
         TECO-11, modulo 128 in other TECOs.) nI` is used to insert characters that are not
         available on the user's terminal or special characters such as DELETE which may not be
         inserted from a terminal with the standard I command.</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>@I/text/</para>
       </entry>
       <entry>
        <para> Equivalent to the I command except that the text to be inserted may contain ESCAPE
         characters. A delimiting character (shown as a slash here) must precede and follow the text
         to be inserted, as described in <xref linkend="CON_TCF_TXT"/> above.</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>n@I//</para>
       </entry>
       <entry>
        <para> Equivalent to the nI` command, but does not require the <literal>&lt;DELIM></literal>
         character.</para>
       </entry>
      </row>
      <row>
       <entry>
        <para><literal>&lt;TAB></literal>text`</para>
       </entry>
       <entry>
        <para> This command is equivalent to the I command except that the
          <literal>&lt;TAB></literal> is part of the text which is inserted into the buffer.</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>FRtext`</para>
       </entry>
       <entry>
        <para> Equivalent to "-nDItext`", where "n" is obtained from the most recent occurrence of
         the following: (a) the length of the most recent string found by a successful search
         command, (b) the length of the most recent text string inserted (including insertions from
         the FS, FN, or FR commands), or (c) the length of the string retrieved by the most recent
         "G" command. In effect, the last string inserted or found is replaced with "text", provided
         that the pointer has not been moved. After execution of this command, the buffer pointer is
         positioned immediately after "text". [Not in TECO-8]</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>@FR/text/</para>
       </entry>
       <entry>
        <para> Equivalent to "FRtext`", except that "text" may contain ESCAPE characters. [Not in
         TECO-8]</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>nFRtext`</para>
       </entry>
       <entry>
        <para> Equivalent to "nDItext`". If n is less than 0, characters preceding the buffer
         pointer are deleted and replaced with "text". If n is greater than 0, characters following
         the buffer pointer are deleted and replaced with "text". In either case, the buffer pointer
         is left positioned immediately after "text" upon completion of this command. [TECO-11
         only]</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>n@FR/text/</para>
       </entry>
       <entry>
        <para> Equivalent to "nFRtext`", except that "text" may contain ESCAPE characters. [TECO-11
         only]</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>m,nFRtext`</para>
       </entry>
       <entry>
        <para> Equivalent to "m,nDItext`". The characters between buffer positions m and n are
         deleted and replaced with "text". The buffer pointer is left positioned immediately after
         "text" upon completion of this command. [TECO-11 only]</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>m,n@FR/text/</para>
       </entry>
       <entry>
        <para> Equivalent to "m,nFRtext`", except that "text" may contain ESCAPE characters.
         [TECO-11 only]</para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para></sect1><sect1 xml:id="COM_SRC"><title>Search Commands</title>
 <para>
 In many cases, the easiest way to position the buffer pointer is
 by means of a character string search. Search commands cause
 TECO to scan through text until a specified string of characters
 is found, and then position the buffer pointer at the end of the
 string. A character string search begins at the current position
 of the pointer. It proceeds within the current buffer in a
 forward or a reverse direction or through the file in a forward
 direction. Specifying a negative numeric argument to the search
 command causes the search to proceed backwards from the pointer.
 </para><para>
 Your last explicitly specified search string is always remembered
 by TECO. If a search command is specified with a null search
 string argument, the last explicitly defined search string will
 be used. This saves having to retype a complex or lengthy search
 string on successive search commands.
 </para><para>
 Normally searches are "unbounded" - they search from the current
 position to the end of the text buffer (or in the case of
 backwards searches, until the beginning of the buffer). A
 bounded search, however, will only search from the current
 position to the specified bound limit. If the search string is
 found within the bound limits, the pointer is positioned
 immediately after the last character in the string. If the
 string cannot be found, the pointer is left unchanged.
 </para><para>
 A special case of the bounded search occurs when the upper and
 lower bound limits are the same. In such a case, the search
 command is called an anchored search, and is used to compare the
 search argument against the character string immediately
 following the text buffer pointer.
 </para><para>
 TECO-8 does not permit backward, bounded, or anchored searches.
 This is a general property and will not be specifically mentioned
 again in the following tables.
 <table xml:id="COM_TAB_SRC"><title>Search Commands</title>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Command</para></entry><entry><para>Function</para></entry>
</row>
</thead>
 <tbody>
<row><entry><para>Stext`</para></entry><entry><para>
 Where "text" is a string of characters terminated by a
 <literal>&lt;DELIM></literal>. This command searches the text buffer for the
 next occurrence of the specified character string
 following the current position of the buffer pointer.
 If the string is found, the pointer is positioned after
 the last character in the string. If it is not found,
 the pointer is positioned immediately before the first
 character in the buffer (i.e., a 0J is executed) and an
 error message is printed.</para></entry></row>
 <row><entry><para>nStext`</para></entry><entry><para>
 This command searches for the nth occurrence of the
 specified character string, where n is greater than
 zero. It is identical to the S command in other
 respects.</para></entry></row>
 <row><entry><para>-nStext`</para></entry><entry><para> Identical to "nStext`" except that the search proceeds in the reverse direction. If the
         string is not found, the pointer is positioned immediately before the first character in
         the buffer and an error message is printed. If the pointer is positioned at the beginning
         of or within an occurrence of the desired string, that occurrence is considered to be the
         first one found. Upon successful completion, the pointer is positioned after the last
         character in the string found.</para></entry></row>
 <row><entry><para>-Stext`</para></entry><entry><para> Equivalent to -1Stext`.</para></entry></row>
 <row><entry><para>Ntext`</para></entry><entry><para>
 Performs the same function as the S command except that
 the search is continued across page boundaries, if
 necessary, until the character string is found or the
 end of the input file is reached. This is accomplished
 by executing an effective P command after each page is
 searched. If the end of the input file is reached, an
 error message is printed and it is necessary to close
 the output file and re-open it as an input file before
 any further editing may be done on that file. The N
 command will not locate a character string which spans
 a page boundary.</para></entry></row>
 <row><entry><para>-Ntext`</para></entry><entry><para>
 Performs the same function as the -S command except
 that the search is continued (backwards) across page
 boundaries, if necessary, until the character string is
 found or the beginning of the file being edited is
 reached.
 [TECO-32 only]</para></entry></row>
 <row><entry><para>-nNtext`</para></entry><entry><para>
 This command searches (backwards) for the nth
 occurrence of the specified character string. It is
 identical to the -N command in other respects.
 [TECO-32 only]</para></entry></row>
 <row><entry><para>nNtext`</para></entry><entry><para>
 This command searches for the nth occurrance of the
 specified character string, where n must be greater
 than zero. It is identical to the N command in other
 respects.</para></entry></row>
 <row><entry><para>_text`</para></entry><entry><para>
 The underscore command is identical to the N command
 except that the search is continued across page
 boundaries by executing effective Y commands instead of
 P commands, so that no output is generated. Since an
 underscore search can result in the loss of data, it is
 aborted under the same circumstances as the Y command
 (see the ED flag in <xref linkend="COM_MCF"/>). Note that
 underscore is backarrow on some terminals.</para></entry></row>
 <row><entry><para>n_text`</para></entry><entry><para>
 This command searches for the nth occurrence of the
 specified character string, where n must be greater
 than zero. It is identical to the _ command in other
 respects.
 In TECO-32 n can be negative, in which case
 the search proceeds backwards through each text buffer
 and through the file being edited. It terminates upon
 the correct search string match and/or beginning of
 file. A -n:_ command returns 0 at beginning of file.</para></entry></row>
 <row><entry><para>E_text`</para></entry><entry><para> Same as _text` command except that effective EY (rather than Y) commands are used. Thus, this
         command is never aborted and is not controlled by the Yank protection bit in the ED flag.
         Remember that Yank DESTROYS the current buffer; there's no way to get it back!</para></entry></row>
 <row><entry><para>nE_text`</para></entry><entry><para> Same as n_text` command except that effective EY (rather than Y) commands are used.</para></entry></row>
 
</tbody>
</tgroup></table>
 </para><para>
 <table xml:id="COM_TAB_BSC"><title>Bounded Search Commands</title>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Command</para></entry><entry><para>Function</para></entry>
</row>
</thead>
 <tbody>
<row><entry><para>m,nStext`</para></entry><entry><para>
 System specific command. Consult <xref linkend="APP_INC"/>.</para></entry></row>
 <row><entry><para>m,nFBtext`</para></entry><entry><para> Performs the same function as the nStext` command, but m and n (inclusive) serve as bounds
         for the search. In order for a search to be successful, the first character to match must
         occur between buffer pointer positions m and n. The string that is matched is permitted to
         extend beyond the search limits specified, provided that it begins within bounds. If
         m&amp;lt;n, then the search proceeds in a forwards direction. If m&amp;gt;n, then the
         search proceeds in the reverse direction.</para></entry></row>
 <row><entry><para>nFBtext`</para></entry><entry><para>
 Performs a bounded search over the next n lines. If n
 is positive, the search proceeds forward over the next
 n lines; if n is negative the search proceeds
 backwards over the n preceding lines; if n is zero,
 the search proceeds backwards over the portion of the
 line preceding the pointer.</para></entry></row>
 <row><entry><para>FBtext`</para></entry><entry><para> Equivalent to 1FBtext`.</para></entry></row>
 <row><entry><para>-FBtext`</para></entry><entry><para> Equivalent to -1FBtext`.</para></entry></row>
 <row><entry><para>::Stext`</para></entry><entry><para> Compare command. The ::S command is not a true search. If the characters in the buffer
         immediately following the current pointer position match the search string, the pointer is
         moved to the end of the string and the command returns a value of -1; i.e., the next
         command is executed with an argument of -1. If the characters in the buffer do not match
         the string, the pointer is not moved and the command returns a value of 0. Identical to
         ".,.:FBtext`".</para></entry></row>
 
</tbody>
</tgroup></table>
 </para><para>
 The search and replace commands listed below perform equivalent
 functions to the search commands listed next to them, but then
 delete "text1" and replace it with "text2".
 <table xml:id="COM_TAB_REP"><title>Search and Replace Commands</title>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Search &amp; Replace</para></entry><entry><para>Search Command</para></entry>
</row>
</thead>
 <tbody>
<row><entry><para>FStext1`text2`</para></entry><entry><para>
 Stext1`</para></entry></row>
 <row><entry><para>nFStext1`text2`</para></entry><entry><para>
 nStext1`</para></entry></row>
 <row><entry><para>FNtext1`text2`</para></entry><entry><para>
 Ntext1`</para></entry></row>
 <row><entry><para>nFNtext1`text2`</para></entry><entry><para>
 nNtext1`</para></entry></row>
 <row><entry><para>F_text1`text2`</para></entry><entry><para>
 _text1`</para></entry></row>
 <row><entry><para>[not in TECO-10]</para></entry><entry><para/></entry></row>
 <row><entry><para>nF_text1`text2`</para></entry><entry><para>
 n_text1`</para></entry></row>
 <row><entry><para>[Not in TECO-10]</para></entry><entry><para/></entry></row>
 <row><entry><para>FCtext1`text2`</para></entry><entry><para>
 FBtext1`</para></entry></row>
 <row><entry><para>nFCtext1`text2`</para></entry><entry><para>
 nFBtext1`</para></entry></row>
 <row><entry><para>m,nFCtext1`text2`</para></entry><entry><para>
 m,nFBtext1`</para></entry></row>
 
</tbody>
</tgroup></table>
 </para><para>
 In addition, the four following commands can be used on TECO-10:
 <table xml:id="COM_TAB_R10"><title>TECO-10 Specific Search and Replace commands</title>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Command</para></entry><entry><para>Function</para></entry>
</row>
</thead>
 <tbody>
<row><entry><para>FDtext`</para></entry><entry><para>
 Identical to the "FStext``" command.
 [TECO-10 only]</para></entry></row>
 <row><entry><para>nFDtext`</para></entry><entry><para>
 Identical to the "nFStext``" command.
 [TECO-10 only]</para></entry></row>
 <row><entry><para>nFKtext`</para></entry><entry><para>
 Searches for the nth following occurrence of "text" and
 then deletes all characters in the text buffer between
 the pointer positions before and after the search.
 [TECO-10 only]</para></entry></row>
 <row><entry><para>FKtext`</para></entry><entry><para>
 Equivalent to 1FKtext`
 [TECO-10 only]</para></entry></row>
 
</tbody>
</tgroup></table>
 </para><para>
 The FS, F_, and FN commands above can also be reverse searches
 (n&lt;0) or bounded searches (m,n argument). A reverse F_ or FN
 acts like a reverse S; that is the search terminates when the
 beginning of the text buffer is encountered.
 </para><para>
 (In TECO-32 -nFN searches backwards through each text
 buffer and through the file being edited. It terminates upon the
 correct search string match and/or beginning of file. A colon
 modified reverse search returns 0 at beginning of file.)
 </para><para>
 If a search command is entered without a text argument, TECO will
 execute the search command as though it had been entered with the
 same character string argument as the last search command
 entered. For example, suppose the command "STHE END`" results in
 an error message, indicating that character string "THE END" was
 not found on the current page. Entering the command "N`" causes
 TECO to execute an N search for the same character string.
 Although the text argument may be omitted, the command terminator
 <literal>&lt;DELIM></literal> must always be entered.
 </para><para>
 Search commands can make use of the colon modifier described in
 <xref linkend="CON"/>. The following examples illustrate use of the colon
 modifier:
 </para><para>
 <emphasis role="bold">Commands:</emphasis>
 <informaltable>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <tbody>
<row><entry><para/></entry><entry><para>n:Stext`</para></entry></row>
 <row><entry><para/></entry><entry><para>m,n:Stext`</para></entry></row>
 <row><entry><para/></entry><entry><para>n:Ntext`</para></entry></row>
 <row><entry><para/></entry><entry><para>n:_text`</para></entry></row>
 <row><entry><para/></entry><entry><para>n:FStext1`text2`</para></entry></row>
 <row><entry><para/></entry><entry><para>m,n:FStext1`text2`</para></entry></row>
 <row><entry><para/></entry><entry><para>n:FNtext1`text2`</para></entry></row>
 <row><entry><para/></entry><entry><para>etc.</para></entry></row>
 
</tbody>
</tgroup></informaltable>
 </para><para>
   <emphasis role="bold">Function:</emphasis></para>
  <para>In each case, execute the search command. If the search is successful, execute the next
   sequential command with an argument of -1. If the search fails, execute the next command with an
   argument of zero. If the next command does not require a numeric argument, execute it as it
   stands. </para><para>
 All search commands may also use the @ modifier to use alternate
 delimiters, to allow <literal>&lt;ESCAPE></literal> characters in search strings or to
 avoid the use of <literal>&lt;ESCAPE></literal> characters in command strings. Such
 search commands take the following forms:
 </para><para>
 <emphasis role="bold">Commands:</emphasis>
 <informaltable>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <tbody>
<row><entry><para/></entry><entry><para>@S/text/</para></entry></row>
 <row><entry><para/></entry><entry><para>m,n@FB/text/</para></entry></row>
 <row><entry><para/></entry><entry><para>n@FS/text1/text2/</para></entry></row>
 <row><entry><para/></entry><entry><para>@:N/text/</para></entry></row>
 <row><entry><para/></entry><entry><para>etc.</para></entry></row>
 
</tbody>
</tgroup></informaltable>
 </para></sect1><sect1 xml:id="COM_SRA"><title>Search Arguments</title>
 <para>
 TECO builds the search string by loading its search string buffer
 from the supplied search command argument. To help you enter
 special characters or frequently used character sequences, the
 argument may contain special string building characters.
 <xref linkend="COM_TAB_SBC"/> lists the string building characters and
 their functions.
 </para><para>
 TECO-8 does not support the extended String Build functions or
 Match Control Constructs that begin with <literal>&lt;CTRL/E></literal>. This is a
 general property and will not be repeated in the following
 tables.
 </para><para>
 Note that, as explained in <xref linkend="CON"/>, a caret (up-arrow) may be
 used to indicate that the character following it is to be treated
 as a control character. Any of the commands below may be entered
 using the caret. This function of the caret can be disabled by
 using the ED flag (see <xref linkend="COM_MCF"/> and appendices).
 <table xml:id="COM_TAB_SBC"><title>String Building Characters</title>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Character</para></entry><entry><para>Function</para></entry>
</row>
</thead>
 <tbody>
<row><entry><para><literal>&lt;CTRL/Q></literal></para></entry><entry><para>
 A <literal>&lt;CTRL/Q></literal> character in a search command argument
 indicates that the character following the
 <literal>&lt;CTRL/Q></literal> is to be used literally rather than as a
 match control character.</para></entry></row>
 <row><entry><para><literal>&lt;CTRL/R></literal></para></entry><entry><para>Same as <literal>&lt;CTRL/Q></literal>.</para></entry></row>
 <row><entry><para><literal>&lt;CTRL/V></literal></para></entry><entry><para>
 A <literal>&lt;CTRL/V></literal> character in a search command argument
 indicates that the character following the
 <literal>&lt;CTRL/V></literal> is to be used as the equivalent character
 in the lower case ASCII range (i.e., octal 100 to
 137 is treated as octal 140 to 177).</para></entry></row>
 <row><entry><para><literal>&lt;CTRL/V></literal><literal>&lt;CTRL/V></literal></para></entry><entry><para>
 Two successive <literal>&lt;CTRL/V></literal> characters in a string
 argument indicate to TECO that all following
 alphabetic characters in this string are to be
 converted to lower case unless an explicit ^W is
 given to override this state. This state
 continues until the end of the string or until a
 ^W^W construct is encountered.
 [TECO-10 only]</para></entry></row>
 <row><entry><para><literal>&lt;CTRL/W></literal></para></entry><entry><para>
 A <literal>&lt;CTRL/W></literal> character in a search command argument
 indicates that the character following the
 <literal>&lt;CTRL/W></literal> is to be used as the equivalent character
 in the upper case ASCII range (i.e., octal 140 to
 177 is treated as octal 100 to 137).</para></entry></row>
 <row><entry><para><literal>&lt;CTRL/W></literal><literal>&lt;CTRL/W></literal></para></entry><entry><para>
 Two successive <literal>&lt;CTRL/W></literal> characters indicates to
 TECO that all following alphabetic characters in
 this string are to be converted to upper case
 unless an explicit ^V is encountered to override
 this state. This state continues until the end of
 the string or until a ^V^V construct is
 encountered.
 [TECO-10 only]</para></entry></row>
 <row><entry><para><literal>&lt;CTRL/E></literal>Qq</para></entry><entry><para>
 <literal>&lt;CTRL/E></literal>Qq indicates that the string stored in
 Q-register q is to be used in the position
 occupied by the ^EQq in the search string. Q
 registers are discussed in sections <xref linkend="CON_DAT_QRG" xrefstyle="select: labelnumber"/> and 
 <xref linkend="COM_QRG" xrefstyle="select: labelnumber"/>.
 [Not in TECO-10]</para></entry></row>
 <row><entry><para><literal>&lt;CTRL/E></literal>Uq</para></entry><entry><para>
 <literal>&lt;CTRL/E></literal>Uq indicates that the character whose
 ASCII code is specified by the numeric storage
 area of Q-register q is to be used in the position
 occupied by the ^EUq in the search string.
 [TECO-11 only]</para></entry></row>
 
</tbody>
</tgroup></table>
 </para><para>
 String build characters are also permitted inside the string
 arguments of the O, EB, ER, EW, and EG commands.
 </para><para>
 TECO executes a search command by attempting to match the search
 command argument character-by-character with some portion of the
 input file. There are several special control characters that
 may be used in search command arguments to alter the usual
 matching process. <xref linkend="COM_TAB_MCC"/> lists these match control
 characters and their functions.
 <table xml:id="COM_TAB_MCC"><title>Match Control Characters</title>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Character</para></entry><entry><para>Function</para></entry>
</row>
</thead>
 <tbody>
<row><entry><para><literal>&lt;CTRL/X></literal></para></entry><entry><para>
 A <literal>&lt;CTRL/X></literal> character indicates that this position
 in the character string may be any character.
 TECO accepts any character as a match for
 <literal>&lt;CTRL/X></literal>.</para></entry></row>
 <row><entry><para><literal>&lt;CTRL/S></literal></para></entry><entry><para>
 A <literal>&lt;CTRL/S></literal> character indicates that any separator
 character is acceptable in this position. TECO
 accepts any character that is not a letter (upper
 or lower case A to Z) or a digit (0 to 9) as a
 match for <literal>&lt;CTRL/S></literal>.</para></entry></row>
 <row><entry><para><literal>&lt;CTRL/N></literal>x</para></entry><entry><para>
 TECO accepts any character as a match for the
 <literal>&lt;CTRL/N></literal>x combination EXCEPT the character which
 follows the <literal>&lt;CTRL/N></literal>. <literal>&lt;CTRL/N></literal> can be combined
 with other special characters. For example, the
 combination <literal>&lt;CTRL/N></literal><literal>&lt;CTRL/E></literal>D means match anything
 except a digit in this position.</para></entry></row>
 <row><entry><para><literal>&lt;CTRL/E></literal>A</para></entry><entry><para>
 <literal>&lt;CTRL/E></literal>A indicates that any alphabetic character
 (upper or lower case A to Z) is acceptable in this
 position.</para></entry></row>
 <row><entry><para><literal>&lt;CTRL/E></literal>B</para></entry><entry><para>
 Same as <literal>&lt;CTRL/S></literal>.</para></entry></row>
 <row><entry><para><literal>&lt;CTRL/E></literal>C</para></entry><entry><para>
 <literal>&lt;CTRL/E></literal>C indicates that any character that is
 legal as part of a symbol constituent is
 acceptable in this position. TECO accepts any
 letter (upper or lower case A to Z), any digit (0
 to 9), a dot (.), or a dollar sign ($) as a match
 for <literal>&lt;CTRL/E></literal>C. Additional characters may be
 matched depending upon the operating system;
 consult the appropriate appendix.</para></entry></row>
 <row><entry><para><literal>&lt;CTRL/E></literal>D</para></entry><entry><para>
 <literal>&lt;CTRL/E></literal>D indicates that any digit (0 to 9) is
 acceptable in this position.</para></entry></row>
 <row><entry><para><literal>&lt;CTRL/E></literal>Gq</para></entry><entry><para>
 <literal>&lt;CTRL/E></literal>Gq indicates that any character contained
 in Q-register q is acceptable in this position.
 For example, if Q-register A contains "A&star;:" then
 TECO accepts either A,&star;, or : as a match for
 <literal>&lt;CTRL/E></literal>GA.
 [Not in TECO-10]</para></entry></row>
 <row><entry><para><literal>&lt;CTRL/E></literal>L</para></entry><entry><para>
 <literal>&lt;CTRL/E></literal>L indicates that any line terminator (line
 feed, vertical tab, or form feed) is acceptable in
 the position occupied by <literal>&lt;CTRL/E></literal>L in the search
 string.</para></entry></row>
 <row><entry><para><literal>&lt;CTRL/E></literal>M</para></entry><entry><para>
 <literal>&lt;CTRL/E></literal>M indicates that any non-zero number of
 occurrences of the immediately following character
 or match control construct is acceptable at this
 position.
 [TECO-10 only]</para></entry></row>
 <row><entry><para><literal>&lt;CTRL/E></literal>R</para></entry><entry><para>
 <literal>&lt;CTRL/E></literal>R indicates that any alphanumeric
 character (letter or digit as defined above) is
 acceptable in this position.</para></entry></row>
 <row><entry><para><literal>&lt;CTRL/E></literal>S</para></entry><entry><para>
 <literal>&lt;CTRL/E></literal>S indicates that any non-null string of
 spaces and/or tabs is acceptable in the position
 occupied by <literal>&lt;CTRL/E></literal>S.</para></entry></row>
 <row><entry><para><literal>&lt;CTRL/E></literal>V</para></entry><entry><para>
 <literal>&lt;CTRL/E></literal>V indicates that any lower case alphabetic
 character is acceptable in this position.</para></entry></row>
 <row><entry><para><literal>&lt;CTRL/E></literal>W</para></entry><entry><para>
 <literal>&lt;CTRL/E></literal>W indicates that any upper case alphabetic
 character is acceptable in this position.</para></entry></row>
 <row><entry><para><literal>&lt;CTRL/E></literal>X</para></entry><entry><para>
 Equivalent to <literal>&lt;CTRL/X></literal>.</para></entry></row>
 <row><entry><para><literal>&lt;CTRL/E></literal><literal>&lt;nnn></literal></para></entry><entry><para>
 <literal>&lt;CTRL/E></literal><literal>&lt;nnn></literal> indicates that the character whose
 ASCII octal code is nnn is acceptable in this
 position.
 [TECO-10 only]</para></entry></row>
 <row><entry><para><literal>&lt;CTRL/E></literal>[a,b,c,...]
 <literal>&lt;CTRL/E></literal>[a,b,c,...]</para></entry><entry><para>
 indicates that any one of the
 specified characters is acceptable in this
 position. One or more characters or other match
 control constructs are permitted.
 [TECO-10 only]</para></entry></row>
 
</tbody>
</tgroup></table>
 </para><para>
 TECO-8 uses special symbols to represent certain match control
 characters when they are displayed by an error message. These
 display symbols are:
 <informaltable>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Character</para></entry><entry><para>Display</para></entry>
</row>
</thead>
 <tbody>
<row><entry><para>^N</para></entry><entry><para><literal>&lt;NOT></literal></para></entry></row>
 <row><entry><para>^S</para></entry><entry><para><literal>&lt;SEP></literal></para></entry></row>
 <row><entry><para>^X</para></entry><entry><para><literal>&lt;ANY></literal></para></entry></row>
 
</tbody>
</tgroup></informaltable>
 </para></sect1><sect1 xml:id="COM_QRG"><title>Q-Register Manipulation</title>
 <para>
 TECO provides data storage registers, called Q-registers, each of
 which may be used to store an integral numeric value and,
 simultaneously, an ASCII character string. Q-registers are
 described in <xref linkend="CON_DAT_QRG"/>; this section describes the commands
 used to load values into and retrieve values from Q-registers.
 </para><para>
 An important kind of character string which may be stored in the
 text portion of a Q-register is a TECO command string. Such a
 command is known as a macro, and is available for execution via
 the Mq command, described in <xref linkend="COM_TAB_MIC"/> below. (See also 
 <xref linkend="CSE_IESC" xrefstyle="select: label title"/>, for a keypad method of
 macro invocation, and <xref linkend="CSE_IAC"/> for the&star;q command which
 saves the last-typed command for possible editing or re-execution.)
 </para><para>
 TECO-10 allows additional Q-registers other than those described
 in <xref linkend="CON_DAT_QRG"/>.
 Consult <xref linkend="APP_TOPS"/> for further details.
 </para><para>
 <xref linkend="COM_TAB_QLC"/> lists the commands which permit characters to be
 loaded into the Q-registers.
 <table xml:id="COM_TAB_QLC"><title>Q-Register Loading Commands</title>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Command</para></entry><entry><para>Function</para></entry>
</row>
</thead>
 <tbody>
<row><entry><para>nUq</para></entry><entry><para>
 Put n in the numeric storage area of Q-register q.</para></entry></row>
 <row><entry><para>m,nUq</para></entry><entry><para>
 Equivalent to the nUqm command. That is, this command
 puts the number n into the numeric storage area of
 Q-register q and then returns the number m as a value.
 The command UAUB is useful at the beginning of a macro
 to save the two arguments specified on the macro call.
 (See the m,nMq command below.)</para></entry></row>
 <row><entry><para>n%q</para></entry><entry><para>
 Add n to the contents of the number storage area of
 Q-register q. The updated contents of Q-register q are
 also returned as a value to be passed to the next
 command.
 If your intent is only to update the Q-register, good
 programming practice suggests following the n%q command
 with a <literal>&lt;DELIM></literal> or ^[ to prevent the returned value from
 unintentionally affecting the following command.</para></entry></row>
 <row><entry><para>n%q`</para></entry><entry><para>
 Same as n%q but discards the value returned.</para></entry></row>
 <row><entry><para>%q</para></entry><entry><para>Equivalent to 1%q.</para></entry></row>
 <row><entry><para>^Uqstring`</para></entry><entry><para>
 This command inserts character string "string" into the
 text storage area of Q-register q. When entering a
 command string from the terminal, you must specify ^U
 using the caret/U format, since the <literal>&lt;CTRL/U></literal> character
 is the line erase immediate action command.</para></entry></row>
 <row><entry><para>:^Uqstring`</para></entry><entry><para>
 This command appends character string "string" to the
 text storage area of Q-register "q".
 [not in TECO-8]</para></entry></row>
 <row><entry><para>n^Uq`</para></entry><entry><para>
 This form of the ^Uq` command inserts the single
 character whose ASCII code is n into the text storage
 area of Q-register "q". (n is taken modulo 256 in
 TECO-11, modulo 128 in other TECOs.)
 [not in TECO-8]</para></entry></row>
 <row><entry><para>n:^Uq`</para></entry><entry><para>
 This form of the :^Uq` command appends the single
 character whose ASCII code is n to the text storage
 area of Q-register "q". (n is taken modulo 256 in
 TECO-11, modulo 128 in other TECOs.)
 [not in TECO-8]</para></entry></row>
 <row><entry><para>@^Uq/string/
 @:^Uq/string/
 n@^Uq//
 n@:^Uq//</para></entry><entry><para>
 Equivalent, respectively, to the ^Uqstring`,
 :^Uqstring`,
 n^Uq`,
 and n:^Uq` commands, except that
 alternate delimiters are used and no <literal>&lt;DELIM></literal> characters
 are necessary.</para></entry></row>
 <row><entry><para>nXq</para></entry><entry><para>
 Clear Q-register q and move n lines into it, where n is
 a signed integer. If n is positive, the n lines
 following the current pointer position are copied into
 the text storage area of Q-register q. If n is
 negative, the n lines preceding the pointer are copied.
 If n is zero, the contents of the buffer from the
 beginning of the line on which the pointer is located
 up to the pointer is copied. The pointer is not moved.
 The text is not deleted.</para></entry></row>
 <row><entry><para>Xq</para></entry><entry><para>Equivalent to 1Xq.</para></entry></row>
 <row><entry><para>-Xq</para></entry><entry><para>Equivalent to -1Xq.</para></entry></row>
 <row><entry><para>m,nXq</para></entry><entry><para>
 Copy the contents of the buffer from the m+1th
 character through and including the nth character into
 the text storage area of Q-register q. M and n must be
 positive, and m should be less than n.</para></entry></row>
 <row><entry><para>.,.+nXq</para></entry><entry><para>
 Copy the n characters immediately following the buffer
 pointer into the text storage area of Q-register q. N
 should be greater than zero.</para></entry></row>
 <row><entry><para>.-n,.Xq</para></entry><entry><para>
 Copy the n characters immediately preceeding the buffer
 pointer into the text storage area of Q-register q. N
 should be greater than zero.</para></entry></row>
 <row><entry><para>n:Xq</para></entry><entry><para>
 Append n lines to Q-register q, where n is a signed
 integer with the same functions as n in the nXq command
 above. The pointer is not moved.
 [not in TECO-8]</para></entry></row>
 <row><entry><para/></entry><entry><para>The colon construct for appending to a Q-register can
 be used with all forms of the X command.</para></entry></row>
 <row><entry><para>]q</para></entry><entry><para>
 Pop from the Q-register push-down list into Q-register
 q. Any previous contents of Q-register q are
 destroyed. Both the numeric and text parts of the
 Q-register are loaded by this command. The Q-register
 push-down list is a last-in first-out (LIFO) storage
 area. (See section 3.3.3 for a description of the
 push-down list.) This command does not use or affect
 numeric values. Numeric values are passed through this
 command transparently. This allows macros to restore
 Q-registers and still return numeric values.
 [Not in TECO-8]</para></entry></row>
 <row><entry><para>:]q</para></entry><entry><para>
 Execute the ]q command and return a numeric value. A
 -1 indicates that there was another item on the
 Q-register push-down list to be popped. A 0 indicates
 that the Q-register push-down list was empty, so
 Q-register q was not modified.
 [Not in TECO-8]</para></entry></row>
 <row><entry><para>&star;q</para></entry><entry><para>
 Save last-typed command string. See <xref linkend="CSE_IAC"/>.</para></entry></row>
 
</tbody>
</tgroup></table>
 </para><para>
 <xref linkend="COM_TAB_QRC"/> lists the commands which permit data to be retrieved
 from the Q-registers.
 <table xml:id="COM_TAB_QRC"><title>Q-Register Retrieval Commands</title>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Command</para></entry><entry><para>Function</para></entry>
</row>
</thead>
 <tbody>
<row><entry><para>Qq</para></entry><entry><para>
 Use the integer stored in the number storage area of
 Q-register q as the argument of the next command.</para></entry></row>
 <row><entry><para>nQq</para></entry><entry><para>
 Return the ASCII value of the (n+1)th character in
 Q-register q. The argument n must be between 0 and the
 Q-register's size minus 1. If n is out of range, a
 value of -1 is returned. Characters within a
 Q-register are numbered the same way that characters in
 the text buffer are numbered. The initial character is
 at character position 0, the next character is at
 character position 1, etc. Therefore, if Q-register A
 contains "xyz", then 0QA will return the ASCII code for
 "x" and 1QA will return the ASCII code for "y".</para></entry></row>
 <row><entry><para>:Qq</para></entry><entry><para>
 Use the number of characters stored in the text storage
 area of Q-register q as the argument of the next
 command.</para></entry></row>
 <row><entry><para>Gq</para></entry><entry><para>
 Copy the contents of the text storage area of
 Q-register q into the buffer at the current position of
 the buffer pointer, leaving the pointer positioned
 after the last character copied.</para></entry></row>
 <row><entry><para>:Gq</para></entry><entry><para>
 Print the contents of the text storage area of
 Q-register q on the terminal. Neither the text buffer
 nor the buffer pointer is changed by this command.</para></entry></row>
 <row><entry><para>[q</para></entry><entry><para>
 Copy the contents of the numeric and text storage areas
 of Q-register q into the Q-register push-down list.
 This command does not alter either the numeric or text
 storage areas of Q-register q. It does not use or
 affect numeric values. Numeric values are passed
 through this command transparently, allowing macros to
 save temporary Q-registers and still accept numeric
 values. (Note, however, macros written to use local
 Q-registers, available in TECO-11, may be able to avoid
 saving and restoring Q-registers via the the pushdown
 list.) The command sequence [A ]B replicates the text
 string and numeric value from Q-register A into
 Q-register B.
 [Not in TECO-8]</para></entry></row>
 
</tbody>
</tgroup></table>
 </para><para>
 <xref linkend="COM_TAB_MIC"/> lists the commands which cause macros (strings stored
 in Q-registers) to be executed.
 </para><para>
 Macro invocations can be nested recursively; the limit is set by
 the amount of pushdown storage TECO has available.
 </para><para>
 In this table only, a distinction is made between a global
 Q-register name (indicated below by "q") and a local Q-register
 name (indicated below by ".q"). Elsewhere in this manual, "q"
 indicates either a global or local Q-register name.
 <table xml:id="COM_TAB_MIC"><title>Macro Invocation Commands</title>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Command</para></entry><entry><para>Function</para></entry>
</row>
</thead>
 <tbody>
<row><entry><para>Mq</para></entry><entry><para>
 Execute the contents of the text storage area of global
 Q-register q as a command string. In TECO-11, a new
 set of local Q-registers is created before the macro is
 invoked.</para></entry></row>
 <row><entry><para>nMq</para></entry><entry><para>
 Execute the Mq command as above, using n as a numeric
 argument for the first command contained in global
 Q-register q. In TECO-11, a new set of local
 Q-registers is created.</para></entry></row>
 <row><entry><para>m,nMq</para></entry><entry><para>
 Execute the Mq command as above, using m,n as numeric
 arguments for the first command contained in global
 Q-register q. In TECO-11, a new set of local
 Q-registers is created.</para></entry></row>
 <row><entry><para>:Mq</para></entry><entry><para>
 Execute the contents of the text storage area of global
 Q-register q as a command string. In TECO-11, the
 current set of local Q-registers remains available to
 the invoked macro; no new set is created.</para></entry></row>
 <row><entry><para>n:Mq</para></entry><entry><para>
 Execute the :Mq command as above, using n as a numeric
 argument for the first command contained in global
 Q-register q. In TECO-11, no new set of local
 Q-registers is created.</para></entry></row>
 <row><entry><para>m,n:Mq</para></entry><entry><para>
 Execute the :Mq command as above, using m,n as numeric
 arguments for the first command contained in global
 Q-register q. In TECO-11, no new set of local
 Q-registers is created.</para></entry></row>
 <row><entry><para>M.q</para></entry><entry><para>
 Execute the contents of the text storage area of local
 Q-register .q as a command string. In TECO-11, no new
 set of local Q-registers is created.</para></entry></row>
 <row><entry><para>nM.q</para></entry><entry><para>
 Execute the M.q command as above, using n as a numeric
 argument for the first command contained in local
 Q-register .q. In TECO-11, no new set of local
 Q-registers is created.</para></entry></row>
 <row><entry><para>m,nM.q</para></entry><entry><para>
 Execute the M.q command as above, using m,n as numeric
 arguments for the first command contained in local
 Q-register .q. In TECO-11, no new set of local
 Q-registers is created.</para></entry></row>
 <row><entry><para>:M.q</para></entry><entry><para>
 Execute the contents of the text storage area of local
 Q-register .q as a command string. In TECO-11, no new
 set of local Q-registers is created.</para></entry></row>
 <row><entry><para>n:M.q</para></entry><entry><para>
 Execute the :M.q command as above, using n as a numeric
 argument for the first command contained in local
 Q-register .q. In TECO-11, no new set of local
 Q-registers is created.</para></entry></row>
 <row><entry><para>m,n:M.q</para></entry><entry><para>
 Execute the :M.q command as above, using m,n as numeric
 arguments for the first command contained in local
 Q-register .q. In TECO-11, no new set of local
 Q-registers is created.</para></entry></row>
 
</tbody>
</tgroup></table>
 </para></sect1><sect1 xml:id="COM_ARI"><title>Arithmetic and Expressions</title>
 <para>
 The numeric argument of a TECO command may consist of a single
 integer, any of the characters listed in <xref linkend="COM_TAB_SNV"/>, the numeric
 contents of any Q-register, or an arithmetic combination of these
 elements. If an arithmetic expression is supplied as a numeric
 argument, TECO will evaluate the expression. All arithmetic
 expressions are evaluated from left to right without any operator
 precedence. Parentheses may be used to override the normal order
 of evaluation of an expression. If parentheses are used, all
 operations within the parentheses are performed, left to right,
 before operations outside the parentheses. Parentheses may be
 nested, in which case the innermost expression contained by
 parentheses will be evaluated first. <xref linkend="COM_TAB_OPR"/> lists all of
 the arithmetic operators that may be used in arithmetic
 expressions.
 <table xml:id="COM_TAB_OPR"><title>Arithmetic Operators</title>
 <tgroup cols="3" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>
<colspec colname="c3"/>

 <thead>
<row>
<entry><para>Operator</para></entry><entry><para>Example</para></entry><entry><para>Function</para></entry>
</row>
</thead>
 <tbody>
<row><entry><para>+</para></entry><entry><para>+2=2</para></entry><entry><para>Ignored if used before the first term in an
 expression.</para></entry></row>
 <row><entry><para>+</para></entry><entry><para>5+6=11</para></entry><entry><para>Addition, if used between terms.</para></entry></row>
 <row><entry><para>-</para></entry><entry><para>-2=-2</para></entry><entry><para>Negation, if used before the first term in an
 expression.</para></entry></row>
 <row><entry><para>-</para></entry><entry><para>8-2=6</para></entry><entry><para>Subtraction, if used between terms</para></entry></row>
 <row><entry><para>&star;</para></entry><entry><para>8&star;2=16</para></entry><entry><para>Multiplication. Used between terms.</para></entry></row>
 <row><entry><para>/</para></entry><entry><para>8/3=2</para></entry><entry><para>Integer division with loss of the remainder.
 Used between terms.</para></entry></row>
 <row><entry><para>&amp;</para></entry><entry><para>12&amp;10=8</para></entry><entry><para>Bitwise logical AND of the binary
 representation of the two terms. Used between the terms.</para></entry></row>
 <row><entry><para>#</para></entry><entry><para>12#10=14</para></entry><entry><para>Bitwise logical OR of the binary of the two
 terms. Used between the terms.</para></entry></row>
 <row><entry><para>^_</para></entry><entry><para>5^_=-6</para></entry><entry><para>Unary one's complement. Used after an
 expression. This is a TECO command that
 complements its argument. Strictly speaking,
 it is not a unary operator.</para></entry></row>
 
</tbody>
</tgroup></table>
 </para><para>
 <table xml:id="COM_TAB_CNV"><title>Conversion and Radix Control Commands</title>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Command</para></entry><entry><para>Function</para></entry>
</row>
</thead>
 <tbody>
<row><entry><para>n=</para></entry><entry><para>This command causes the value of n to be output at the
 terminal in decimal followed by a carriage return and
 line feed. Decimal numeric conversion is signed. For
 example, the unsigned number 65535 will output as -1 on
 TECO-11. TECO's radix is unaltered.</para></entry></row>
 <row><entry><para>n==</para></entry><entry><para>This command causes the value of n to be output at the
 terminal in octal (base 8) followed by a carriage
 return and line feed. Octal numeric conversion is
 unsigned. For example, the unsigned number 8191
 (decimal) will output as 17777 on TECO-8. TECO's radix
 is unaltered.</para></entry></row>
 <row><entry><para>n===</para></entry><entry><para>This command causes the value of n to be output at the
 terminal in hexadecimal (base 16) followed by a
 carriage return and line feed. Hexadecimal output is
 unsigned. TECO's radix is unaltered.
 [TECO-11 only]</para></entry></row>
 <row><entry><para>n:=
 n:==
 n:===</para></entry><entry><para>These commands are equivalent to n=, n==, and n===,
 except that they leave the carriage positioned at the
 end of the output.</para></entry></row>
 <row><entry><para>^O</para></entry><entry><para>
 <literal>&lt;CTRL/O></literal> (caret/O) causes all subsequent numeric input
 to be accepted as octal numbers. Numeric conversions
 using the \ or n\ commands will also be octal. The
 digits 8 and 9 become illegal as numeric characters.
 The octal radix will continue to be used until the next
 ^D command is executed or until TECO's radix is changed
 by an n^R command.
 NOTE: On TECO-10, this command only affects the
 immediately following digit string.</para></entry></row>
 <row><entry><para>^D</para></entry><entry><para>
 <literal>&lt;CTRL/D></literal> (caret/D) causes all subsequent numeric input
 to be accepted as decimal numbers. This is the initial setting.
 [Not in TECO-10]</para></entry></row>
 <row><entry><para>^R</para></entry><entry><para>This command returns the binary value of TECO's current
 radix.
 [TECO-11 only]</para></entry></row>
 <row><entry><para>n^R</para></entry><entry><para>This command sets TECO's radix to the value of n. It
 is currently implemented only in TECO-11, where n may
 only be one of the values 8, 10, or 16 (representing
 octal mode, decimal mode, or hexadecimal mode). If n
 is not one of these values, TECO's radix remains
 unchanged and the ?IRA error message is produced.</para></entry></row>
 <row><entry><para>\</para></entry><entry><para>A backslash character which is not preceded by a
 numeric argument causes TECO to evaluate the digit
 string (if any) beginning with the character
 immediately following the buffer pointer and ending at
 the next character that is not valid for the current
 radix. The value becomes the numeric argument of the
 next command. The first character may be a digit or +
 or -. As the backslash command is evaluated, TECO
 moves the buffer pointer to a position immediately
 following the digit string. If there is no digit
 string following the pointer, the result is zero and
 the pointer position remains unchanged. Except on
 TECO-8, the digits 8 and 9 will stop the evaluation if
 TECO's current radix is octal.</para></entry></row>
 <row><entry><para>n\</para></entry><entry><para>The backslash command preceded by an argument inserts
 the value of n into the text buffer at the current
 position of the pointer, leaving the pointer positioned
 after the last digit of the insertion. The insertion
 is either signed decimal (decimal radix), unsigned
 octal (octal radix), or unsigned hexadecimal
 (hexadecimal radix). Note that \ is a "bidirectional"
 command. n\ inserts a string into text while \ (no
 argument) returns a numeric result.</para></entry></row>
 
</tbody>
</tgroup></table>
 </para></sect1><sect1 xml:id="COM_SNV"><title>Special Numeric Values</title>
 <para>
 TECO maintains several internal variables which record conditions
 within TECO. The variable name is equivalent to the current
 contents of the variable and may be entered as a numeric argument
 to TECO commands. When the command is executed, the current
 value of the designated variable becomes the numeric argument of
 the command.
 </para><para>
 Some of the characters which stand for specific values associated
 with the text buffer have been introduced earlier in this manual.
 For example, the dot character (.), which represents the current
 pointer position, may be used in the argument of a T command.
 The command ".,.+5T" causes the 5 characters following the buffer
 pointer to be typed out. When this command is executed, the
 number of characters preceding the buffer pointer is substituted
 in each case for the "dot". The addition is then carried out,
 and the command is executed as though it were of the form "m,nT".
 </para><para>
 <xref linkend="COM_TAB_SNV"/> lists all of the characters which have special
 numeric values. Any of these characters may be used as numeric argument
 in place of the value it represents.
 <table xml:id="COM_TAB_SNV"><title>Characters Associated with Numeric Quantities</title>
 <tgroup cols="3" align="left" colsep="1" rowsep="1">
     <colspec colname="c1"/>
     <colspec colname="c2"/>
     <colspec colname="newCol3"/>
     <thead>
      <row>
       <entry>
        <para>Character</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para>Function</para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>B</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para>Always equivalent to zero. Thus, B represents the position preceding the first
         character in the buffer.</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>Z</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para>Equivalent to the number of characters currently contained in the buffer. Thus, Z
         represents the position following the last character in the buffer.</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>.</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para>Equivalent to the number of characters between the beginning of the buffer and the
         current position of the pointer. Thus "." represents the current position of the
         pointer.</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>H</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para>Equivalent to the numeric pair "B,Z", or "from the beginning of the buffer up to the
         end of the buffer." Thus, H represents the whole buffer.</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>nA</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para>Equivalent to the ASCII code for the .+n+1th character in the buffer (that is, the
         character to the right of buffer pointer position .+n). The expression -1A is equivalent to
         the ASCII code of the character immediately preceding the pointer and 0A is equivalent to
         the ASCII code of the character immediately following the pointer (the current character).
         If the character position referenced lies outside the bounds of the text buffer, this
         command returns a -1.</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>Mq</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para>The Mq command (execute the contents of the text storage area of Q-register "q" as a
         command string) may return a numeric value if the last command in the string returns a
         numeric value and is not followed by a <literal>&lt;ESC></literal>.</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>Qq</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para>Equivalent to the value stored in the number storage area of Q-register q.</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>:Qq</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para>Equivalent to the number of characters in the text storage area of Q-register q. [Not
         in TECO-8]</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>\</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para>Backslash is equivalent to the numeric value of the digit string in the text buffer at
         the current pointer position, interpreted in the current radix. The pointer is moved to the
         end of the digit string.</para>
       </entry>
      </row>
      <row>
       <entry morerows="8">
        <para>^B</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para><literal>&lt;CTRL/B></literal> (caret/B) is equivalent to the current date via the
         following equations: </para>
       </entry>
      </row>
      <row>
       <entry>
        <para><emphasis role="bold">system</emphasis></para>
       </entry>
       <entry>
        <para><emphasis role="bold">encoding</emphasis></para>
       </entry>
      </row>
      <row>
       <entry>
        <para>OS/8</para>
       </entry>
       <entry>
        <para>(((month&star;32)+day)&star;8)+((year-1970)&amp;7)+k</para>
       </entry>
      </row>
      <row>
       <entry/>
       <entry>
        <para>where k = 4096 if year>1977 and k=0 otherwise</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>RT-11</para>
       </entry>
       <entry>
        <para>(((month&star;32)+day)&star;32)+year-1972</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>RSTS/E</para>
       </entry>
       <entry>
        <para>((year-1970)&star;1000)+day within year</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>RSX-11</para>
       </entry>
       <entry>
        <para>((year-1900)&star;16+month)&star;32+day</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>VAX/VMS</para>
       </entry>
       <entry>
        <para>((year-1900)&star;16+month)&star;32+day</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>TOPS-10</para>
       </entry>
       <entry>
        <para>(((year-1964)&star;12+month-1)&star;31+day-1)</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>^E</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para><literal>&lt;CTRL/E></literal> (caret/E) determines whether or not the P command (and
         related operations) append a form feed to the contents of the buffer on output. If ^E is
         -1, a form feed is appended; if ^E is 0, no form feed is appended. Each time text is read
         into the text buffer TECO sets the ^E flag. If the text read terminated due to a form feed
         (i.e., if the text buffer was loaded with a "complete page"), ^E is set to -1. If the text
         read terminated because the buffer was filled to capacity before a form feed was
         encountered or because there was no form feed (i.e., the text buffer was not loaded with a
         "complete page"), ^E is set to 0. In TECO-11, you can set the ^E flag's value directly,
         overriding the value set by the most recent buffer read. Be sure to use only values of 0 or
         -1; other values may cause unpredictable results.</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>^F</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para>
         <literal>&lt;CTRL/F></literal> (caret/F) is equivalent to the current value of the console
         switch register.</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>n^F</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para> n<literal>&lt;CTRL/F></literal> is the terminal number plus 200000 (octal) for job
         n's terminal. -1^F is the terminal number plus 200000 (octal) for your job's terminal. The
         result is 0 if the specified job is detached or if there is no such job. [TECO-10
         only]</para>
       </entry>
      </row>
      <row>
       <entry morerows="7">
        <para>^H</para>
       </entry>
       <entry nameend="newCol3" namest="c2">
        <para>
         <literal>&lt;CTRL/H></literal> (caret/H) is equivalent to the current time of day via the
         following equations: </para>
       </entry>
      </row>
      <row>
       <entry>
        <para><emphasis role="bold">system</emphasis></para>
       </entry>
       <entry>
        <para><emphasis role="bold">encoding</emphasis></para>
       </entry>
      </row>
      <row>
       <entry>
        <para>OS/8:</para>
       </entry>
       <entry>
        <para>0</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>RT-11</para>
       </entry>
       <entry>
        <para>(seconds since midnight)/2</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>RSTS/E</para>
       </entry>
       <entry>
        <para>minutes until midnight</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>RSX-11</para>
       </entry>
       <entry>
        <para>(seconds since midnight)/2</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>VAX/VMS</para>
       </entry>
       <entry>
        <para>(seconds since midnight)/2</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>TOPS-10</para>
       </entry>
       <entry>
        <para>60ths of a second since midnight (or 50ths of a second where 50 Hz power is
         used)</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>^N</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para><literal>&lt;CTRL/N></literal> (caret/N) is the end of file flag. It is equivalent to
         -1 if the file open on the currently selected input stream is at end of file, and zero
         otherwise.</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>^S</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para>
         <literal>&lt;CTRL/S></literal> (caret/S) is equivalent to the negative of the length of the
         last insert, string found, or string inserted with a "G" command, whichever occurred last.
         To back up the pointer to the start of the last insert, string found, etc., type "^SC".
         [Not in TECO-8]</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>^T</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para>
         <literal>&lt;CTRL/T></literal> (caret/T) is equivalent to the ASCII code for the next
         character typed at the terminal. Every ^T command executed causes TECO to pause and accept
         one character typed at the terminal. See the ET flag description (<xref linkend="COM_MCF"
         />) for variations.</para>
       </entry>
      </row>
      <row>
       <entry morerows="8">
        <para>:^T</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para>Reads and decodes the next keystroke typed at the terminal. The decoded keystroke is
         returned in a manner similar to that used for immediate ESCape sequence commands (see <xref
          linkend="CSE_IESC"/>), i.e., via <literal>&lt;type></literal> and
          <literal>&lt;value></literal> codes, as follows: </para>
       </entry>
      </row>
      <row>
       <entry>
        <para><literal>&lt;type></literal></para>
       </entry>
       <entry>
        <para><literal>&lt;value></literal></para>
       </entry>
      </row>
      <row>
       <entry>
        <para>0</para>
       </entry>
       <entry>
        <para>Normal character, <literal>&lt;value></literal> is ASCII value</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>1</para>
       </entry>
       <entry>
        <para>Control character (except ESCape or CSI); <literal>&lt;value></literal> is ASCII value
         of control char. A typed <literal>&lt;CR></literal> yields <literal>&lt;type></literal> 1
          <literal>&lt;value></literal> 13, and subsequent ^T or :^T does not return a
          <literal>&lt;LF></literal>.</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>2</para>
       </entry>
       <entry>
        <para>Same as immed ESC seq <literal>&lt;type></literal> 0</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>3</para>
       </entry>
       <entry>
        <para>Same as immed ESC seq <literal>&lt;type></literal> 1</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>4</para>
       </entry>
       <entry>
        <para>Same as immed ESC seq <literal>&lt;type></literal> 2</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>5</para>
       </entry>
       <entry>
        <para>Same as immed ESC seq <literal>&lt;type></literal> 3</para>
       </entry>
      </row>
      <row>
       <entry namest="c2" nameend="newCol3">
        <para>[TECO-11 only]</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>^Y</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para>
         <literal>&lt;CTRL/Y></literal> (caret/Y) is equivalent to ".+^S,.", the n,m numeric
         argument spanning the text just searched for or inserted. This value may be used to recover
         from inserting a string in the wrong place. Type "^YXSFR`" to store the string in
         Q-register S and remove it from the buffer. You can then position the pointer to the right
         place and type "GS" to insert the string. [TECO-11 only]</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>^Z</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para><literal>&lt;CTRL/Z></literal> (caret/Z) is equivalent to the total space occupied by
         text in the Q-registers (including the command line currently being executed). [TECO-11
         only]</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>^^x</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para>The combination of the Control-caret (double caret or double up-arrow) followed by any
         character is equivalent to the value of the ASCII code for that character. The "x" in this
         example may be any character that can be typed in to TECO.</para>
       </entry>
      </row>
     </tbody>
    </tgroup></table>
 </para><bridgehead>Mode Control Flags</bridgehead>
 <para>
 The following mode control flags return numeric values. The use
 of these flags is described below in <xref linkend="COM_MCF"/>.
 <informaltable>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Flag</para></entry><entry><para>Meaning</para></entry>
</row>
</thead>
 <tbody>
<row><entry><para>ED</para></entry><entry><para>Equivalent to the current value of the edit level flag.</para></entry></row>
 <row><entry><para>EH</para></entry><entry><para>Equivalent to the current value of the help level flag.</para></entry></row>
 <row><entry><para>EO</para></entry><entry><para>Equivalent to the version number of the version of TECO
 which is currently being run. This manual describes
 TECO-11 Version 40, TECO-8 Version 7, and TECO-10 Version 3.</para></entry></row>
 <row><entry><para>ES</para></entry><entry><para>Equivalent to the current value of the search
 verification flag.
 [Not in TECO-8]</para></entry></row>
 <row><entry><para>ET</para></entry><entry><para>Equivalent to the current value of the type out control flag.</para></entry></row>
 <row><entry><para>EU</para></entry><entry><para>Equivalent to the current value of the upper/lower case flag.</para></entry></row>
 <row><entry><para>EV</para></entry><entry><para>Equivalent to the current value of the edit verify flag.
 [TECO-11 only]</para></entry></row>
 <row><entry><para>^X</para></entry><entry><para>
 <literal>&lt;CTRL/X></literal> (caret/X) is equivalent to the current value
 of the search mode flag.
 [Not in TECO-8]</para></entry></row>
 
</tbody>
</tgroup></informaltable>
 </para></sect1><sect1 xml:id="COM_LOO"><title>Command Loops</title>
 <para>
 You can cause a command string to be executed any number of times
 by placing the command string within angle brackets and preceding
 the brackets with a numeric argument designating the number of
 iterations. Iterated command strings are called command loops.
 Loops may be nested so that one command loop contains another
 command loop, which, in turn, contains other command loops, and
 so on. The maximum depth to which command loops may be nested is
 determined by the size of TECO's push-down list (system
 dependent), but is always greater than 10.
 </para><para>
 The general form of the command loop is:
 </para>
  <screen>n<literal>&lt;command string></literal></screen><para>
 where "command string" is the sequence of commands to be iterated
 and n is the number of iterations. If n is not supplied then no
 limit is placed on the number of iterations. If n is 0 or less
 than 0 then the iteration is not executed at all; command
 control skips to the closing angle bracket. If n is greater than
 0, then the iteration is performed n times.
 </para><para>
 Search commands inside command loops are treated specially. If a
 search command which is not preceded by a colon modifier is
 executed within a command loop and the search fails, a warning
 message is printed [on TECO-11], the command loop is exited
 immediately and the command following the right angle bracket of
 the loop is the next command to be executed. If an unmodified
 search command in a command loop is immediately followed by a
 semicolon, it is treated as if it were a colon-modified search
 (see <xref linkend="COM_BRC"/>).
 </para></sect1><sect1 xml:id="COM_BRC"><title>Branching Commands</title>
 <para> TECO provides an unconditional branch command and a set of conditional execution commands.
   To branch within a command string, you must be able to name locations inside the string. TECO
   permits location tags of the form: </para>
  <screen>!tag!</screen><para>
 to be placed between any two commands in a command string. The
 name "tag" will be associated with this location when the command
 string is executed. Tags may contain any number of ASCII
 characters and any character except an exclamation mark. (When
 using the @ form of this command, any character except the
 delimiter is legal.) Since tags are ignored by TECO except when a
 branch command references the tagged location, they may also be
 used as comments within complicated command strings.
 </para><para>
 The unconditional branch command is the O command which has the
 form:
 </para>
  <screen>Otag`</screen><para>
 where "tag" is a location named elsewhere in the command string
 and "`" signifies a <literal>&lt;DELIM></literal>. When an O
 command is executed, the
 next command to be executed will be the one that follows the tag
 referenced by the O command. Command execution continues
 normally from this point.
 </para><para>
 Use of the O command is subject to two restrictions. First, if
 an O command is stored in a Q-register as part of a command
 string which is to be executed by an M command, the tag
 referenced by the O command must reside in the same Q-register.
 </para><para>
 Second, an O command which is inside a command loop may not
 branch to a tagged location preceding the command loop. However,
 it is always possible to branch out of a command loop to a
 location which follows the command loop and then branch to the
 desired tag.
 </para><para>
 The string argument in the O command has the same format as the
 string arguments in the search and E commands. String build
 characters such as ^EQq can be embedded within the string in
 TECO-11. Also, in TECO-11 and TECO-10, the O command may be
 @-sign modified. In that case, the syntax of the command would
 be @O/tag/ where / represents any delimiting character that does
 not appear within the tag.
 </para><para>
 Branching into a conditional poses no problems, but branching
 into a command loop will causes unpredictable results.
 </para><para>
 Although tags may contain any sequence of ASCII characters, good
 programming practice dictates that tags should not contain
 unusual characters (such as space, comma, ESCAPE, etc.) and that
 they should be mnemonic for the piece of code to which they
 refer.
 </para><para>
 There are many other branching commands. Most of these are
 considerably faster than the O command and should be used
 wherever convenient. They are all described in the table below.
 <table xml:id="COM_TAB_BRC"><title>Branching Commands</title>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Command</para></entry><entry><para>Function</para></entry>
</row>
</thead>
 <tbody>
<row><entry><para>Otag`</para></entry><entry><para>
 This command causes TECO to branch to the first
 occurrence of the specified label (tag) in the current
 macro level. In TECO-8 and TECO-11, branching to the
 left of the start of the current iteration is not
 permitted, and this command will only look for an
 occurrence of the specified tag following the &lt; of the
 current iteration, if you are in an iteration. In any
 case, branching out of an iteration is poor programming
 practice. Command execution resumes at the first
 character after the delimiter terminating the specified
 tag. Using this syntax, any character except <literal>&lt;ESC></literal> is
 permitted in the tag specification. The usual string
 build characters are permitted when specifying the tag.</para></entry></row>
 <row><entry><para>@O/tag/</para></entry><entry><para>
 Equivalent to Otag` except that a delimiter (shown here
 as /) is used before and after the specified tag. Any
 character other than that delimiter is permitted inside
 the tag. The usual string build characters are
 permitted when specifying the tag.
 [Not in TECO-8]</para></entry></row>
 <row><entry><para>nOtag0,tag1,
 tag2,...`</para></entry><entry><para>
 This command causes TECO to branch to the tag specified
 by the nth tag in the accompanying list. The string
 argument to this command consists of a sequence of tags
 separated by commas. The tags may contain any
 characters other than comma or <literal>&lt;ESC></literal>; however, good
 programming practice suggests that the tags should
 consist only of letters and digits. There must be no
 intervening spaces since these would be considered part
 of the tag. If n is out of range, or if n selects a
 null tag, then command execution continues with the
 first command following the <literal>&lt;DELIM></literal> that delimits this
 command. (A null tag would be signified in the list by
 two adjacent commas.)
 [TECO-11 only]</para></entry></row>
 <row><entry><para>n@O/tag0,tag1,
 tag2,.../</para></entry><entry><para>
 Same as the preceding command except that the list of
 tags is bracketed by a delimiter shown here as "/".
 The delimiter can be any character that does not appear
 within the list of tags. In particular, using comma
 for the delimiter would not be very useful.
 [TECO-11 only]</para></entry></row>
 <row><entry><para>;</para></entry><entry><para>This command causes TECO to branch out of the current
 iteration, if the immediately preceding search (or
 search and replace) command failed. In that case,
 control resumes at the character following the matching
 > at the end of the current iteration. On the other
 hand, if the preceding search succeeded, command
 execution continues with the character following the ;.
 If this command is encountered from outside of an
 iteration (in the current macro level), then the ?SNI
 error message is issued.</para></entry></row>
 <row><entry><para>n;</para></entry><entry><para>This command causes TECO to branch out of the current
 iteration if the value of n is greater than or equal to
 0. In that case, command execution resumes at the
 character following the matching > at the end of the
 current iteration. On the other hand, if n is less
 than 0, command execution continues with the character
 following the ;. If this command is encountered from
 outside of an iteration (in the current macro level),
 then the ?SNI error message is issued.</para></entry></row>
 <row><entry><para>:;</para></entry><entry><para>This command causes TECO to branch out of the current
 iteration if the immediately preceding search (or
 search and replace) command succeeded. In that case,
 control resumes at the character following the matching
 > at the end of the current iteration. On the other
 hand, if the preceding search failed, command execution
 continues with the character following the ;. If this
 command is encountered from outside of an iteration (in
 the current macro level), then the ?SNI error message
 is issued.
 [TECO-11 only]</para></entry></row>
 <row><entry><para>n:;</para></entry><entry><para>This command causes TECO to branch out of the current
 iteration if the value of n is less than 0. In that
 case, command execution resumes at the character
 following the matching > at the end of the current
 iteration. On the other hand, if n is greater than or
 equal to 0, command execution continues with the
 character following the ;. If this command is
 encountered from outside of an iteration (in the
 current macro level), then the ?SNI error message is
 issued.
 [TECO-11 only]</para></entry></row>
 <row><entry><para>'</para></entry><entry><para>This "command" is actually part of the syntax of TECO
 conditionals. It has no affect if "executed" other
 than to signify termination of the current conditional
 level. If an argument is specified to this command,
 the result is not defined. (Arguments pass through
 this command on TECO-11.) Conditionals are described in
 <xref linkend="COM_CEC"/>.</para></entry></row>
 <row><entry><para>|</para></entry><entry><para>This "command" is actually part of the syntax of TECO
 conditionals. If executed, it causes control to branch
 to the end of the conditional. Command execution
 resumes with the character following the ' that ends
 the current conditional with the ELSE clause being
 skipped.</para></entry></row>
 <row><entry><para>></para></entry><entry><para>This "command" is actually part of the syntax of TECO
 iterations. If executed, it causes TECO to bump the
 current iteration count by 1 and test to see if the
 resulting count is equal to the maximum count permitted
 for the iteration (specified as an argument before the
 matching &lt;). If the iteration count has not expired,
 then control returns to the command following the &lt; at
 the beginning of the current iteration. If the
 iteration has expired, then command execution continues
 with the character following this >. If this command
 is encountered outside of an iteration (within the
 current macro level), then the ?BNI error message (or
 its equivalent) is issued.</para></entry></row>
 <row><entry><para>F></para></entry><entry><para>This command causes TECO to branch (flow) to the end of
 the current iteration. TECO effectively resumes
 execution at the matching >. The iteration count is
 tested as usual. If it has not expired, control
 returns back to the start of the iteration with the
 count having been incremented by 1. If the count was
 up, the iteration is exited and control continues with
 the first command after the >. If this command is
 encountered outside of an iteration, it has the same
 effect as the <literal>&lt;DELIM></literal><literal>&lt;DELIM></literal> command.
 [TECO-11 only]</para></entry></row>
 <row><entry><para>F&lt;</para></entry><entry><para>This command causes TECO to branch (flow) to the start
 of the current iteration. TECO effectively resumes
 execution at the first command following the &lt; at the
 beginning of the current iteration. The iteration
 count is not affected. If this command is issued
 outside of an iteration, it causes TECO to branch back
 to the start of the current command string (in the
 current macro level).
 [TECO-11 only]</para></entry></row>
 <row><entry><para>F'</para></entry><entry><para>This command causes TECO to branch (flow) to the end of
 the current conditional. TECO effectively resumes
 execution at the first command following the ' at the
 end of the current conditional. Numeric arguments are
 eaten up by this command. If this command is issued
 while not in a conditional, the ?MAP error (or its
 equivalent) is issued.
 [TECO-11 only]</para></entry></row>
 <row><entry><para>F|</para></entry><entry><para>This command causes TECO to branch (flow) to the else
 clause of the current conditional. TECO effectively
 resumes execution at the first command following the |
 at the end of the current THEN clause. If the current
 conditional has no ELSE clause, or if an unmatched ' is
 encountered before an unmatched |, then control resumes
 at the command following the ' . Numeric arguments are
 eaten up by this command. If this command is issued
 while not in a conditional, the ?MAP error (or its
 equivalent) is issued. Well-structured programs should
 not need to use this command.
 [TECO-11 only]</para></entry></row>
 <row><entry><para>$$</para></entry><entry><para>
 The <literal>&lt;ESC></literal><literal>&lt;ESC></literal> command causes TECO to exit from the
 current macro level. If this command is issued from
 top level (not from within a macro), then the command
 string execution is terminated and TECO returns to
 prompt level. Note that the second <literal>&lt;ESC></literal> must be a
 true ESCape and may not be a ^[. Also, note that both
 ESCapes must be true TECO commands and not part of the
 syntax of some previous command. That is, the first
 <literal>&lt;ESC></literal> does not count if it is the delimiting ESCape of
 a string. Finally, note that these must be real ESCape
 characters, and not the user-designated <literal>&lt;DELIM></literal>
 character (which TECO understands as an ESCape only
 when typed at the terminal).</para></entry></row>
 <row><entry><para>n$$</para></entry><entry><para>This command causes TECO to exit from the current macro
 level, returning the number n as a value. This value
 will be used as the numeric argument to the first
 command following the macro call.</para></entry></row>
 <row><entry><para>m,n$$</para></entry><entry><para>This command causes TECO to exit from the current macro
 level, returning the pair of values m and n as
 arguments to the first command following the macro
 call. Good programming practice dictates that all ways
 of exiting a macro return the same number of arguments.</para></entry></row>
 <row><entry><para>^C</para></entry><entry><para>
 The <literal>&lt;CTRL/C></literal> (Caret-C) command when executed as a TECO
 command, causes command execution to stop and control
 return to TECO's prompt. No clean-up of push-down
 lists, flag settings, etc. is done. This command lets
 a macro abort TECO's command execution.
 [On TECO-8 and TECO-10, this command causes control to
 return to the operating system.]
 [On TECO-11, this command returns to the operating
 system if executed from the top level.]
 Consult the appendices for specific details concerning
 your operating system.</para></entry></row>
 <row><entry><para>^C<literal>&lt;CTRL/C></literal></para></entry><entry><para>
 This command causes TECO to unconditionally abort and
 control exits from TECO. Control returns to the
 operating system. The second <literal>&lt;CTRL/C></literal> must be a true
 <literal>&lt;CTRL/C></literal> and may not be a Caret-C.</para></entry></row>
 
</tbody>
</tgroup></table>
 </para></sect1><sect1 xml:id="COM_CEC"><title>Conditional Execution Commands</title>
 <para>
 All conditonal execution commands are of the form:
 </para>
  <screen>n"X command-string '</screen><para> or </para>
  <screen>n"X then-command-string | else-command-string '</screen><para>
 In the first form of the command, "n" is a numeric argument on
 which the decision is based, "X" is any of the conditional
 execution commands listed in table 5-14, and "command string" is
 the command string which will be executed if the condition is
 satisfied. The numeric argument is separated from the
 conditional execution command by a double quote (") and the
 command string is terminated with an apostrophe ('). If the
 condition is not satisfied, the command string will not be
 executed; execution will continue with the first command after
 the apostrophe.
 </para><para>
 In the second form of the command, two command strings are
 specified. The first one is executed if the condition is
 satisfied and the second is executed if the condition is not
 satisfied. Only one of the command strings will be executed.
 After execution of the appropriate command string, control will
 continue with the first command after the apostrophe (unless the
 command string caused a branch out of the conditional to occur),
 since execution of the vertical bar command (|) causes TECO to
 scan to the next matching apostrophe.
 </para><para>
 Conditional commands are similar to the IF-THEN-ELSE constructs
 that you find in other structured programming languages, although
 none can match the brevity and elegance of TECO's implementation.
 Nonetheless, you must use these facilities wisely. Good
 programming practice dictates that a branch into the range of a
 conditional (from outside that range) should not occur.
 </para><para>
 Conditional execution commands may be nested in the same manner
 as iteration commands. That is, the command string which is to
 be executed if the condition on n is met may contain conditional
 execution commands, which may, in turn, contain further
 conditional execution commands.
 <table xml:id="COM_TAB_CEC"><title>Conditional Execution Commands</title>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Command</para></entry><entry><para>Function</para></entry>
</row>
</thead>
 <tbody>
<row><entry><para>n"A</para></entry><entry><para>Execute the following command string if n equals the
 ASCII code for an alphabetic character (upper or lower
 case A to Z).</para></entry></row>
 <row><entry><para>n"C</para></entry><entry><para>Execute the following command string if n is the ASCII
 code of any character that is a symbol constituent.
 This is usually one of the upper or lower case letters
 A to Z, one of the digits 0 to 9, or period, or dollar
 sign, but may include additional characters on some
 operating systems. Consult the appropriate appendix.</para></entry></row>
 <row><entry><para>n"D</para></entry><entry><para>Execute the following command string if n equals the
 ASCII code for a digit (0 to 9).</para></entry></row>
 <row><entry><para>n"E</para></entry><entry><para>Execute the following command string if n is equal to
 zero.</para></entry></row>
 <row><entry><para>n"F</para></entry><entry><para>Execute the following command string if n is FALSE.
 Equivalent to n"E.</para></entry></row>
 <row><entry><para>n"G</para></entry><entry><para>Execute the following command string if n is greater
 than zero.</para></entry></row>
 <row><entry><para>n"L</para></entry><entry><para>Execute the following command string if n is less than
 zero.</para></entry></row>
 <row><entry><para>n"N</para></entry><entry><para>Execute the following command string if n is not equal
 to zero.</para></entry></row>
 <row><entry><para>n"R</para></entry><entry><para>Execute the following command string if n equals the
 ASCII code for an alphanumeric (upper or lower case A
 to Z or 0 to 9).</para></entry></row>
 <row><entry><para>n"S</para></entry><entry><para>Execute the following command string if n is
 SUCCESSFUL. Equivalent to n"L.</para></entry></row>
 <row><entry><para>n"T</para></entry><entry><para>Execute the following command string if n is TRUE.
 Equivalent to n"L.</para></entry></row>
 <row><entry><para>n"U</para></entry><entry><para>Execute the following command string if n is
 UNSUCCESSFUL. Equivalent to n"E.</para></entry></row>
 <row><entry><para>n"V</para></entry><entry><para>Execute the following command string if n equals the
 ASCII code for a lower case alphabetic character (lower
 case A to Z).
 [Not in TECO-8]</para></entry></row>
 <row><entry><para>n"W</para></entry><entry><para>Execute the following command string if n equals the
 ASCII code for an upper case alphabetic character
 (upper case A to Z).
 [Not in TECO-8]</para></entry></row>
 <row><entry><para>n"&lt;</para></entry><entry><para>Identical to n"L</para></entry></row>
 <row><entry><para>n"></para></entry><entry><para>Identical to n"G</para></entry></row>
 <row><entry><para>n"=</para></entry><entry><para>Identical to n"E</para></entry></row>
 
</tbody>
</tgroup></table>
 </para></sect1><sect1 xml:id="COM_REC"><title>Retrieving Environment Characteristics</title>
 <para>
 The following TECO commands return values of interest to users
 who want information about their current job, the operating
 system, their terminal, etc.
 </para><para> All negative EJ commands return an operating system dependent value. Consult the appendices
   for operating system unique commands. <table xml:id="COM_TAB_REC">
    <title>Retrieving Environment Characteristics</title>
    <tgroup cols="5" align="left" colsep="1" rowsep="1">
     <colspec colname="c1"/>
     <colspec colname="c2"/>
     <colspec colname="newCol3"/>
     <colspec colname="newCol4"/>
     <colspec colname="newCol5"/>
     <thead>
      <row>
       <entry>
        <para>Command</para>
       </entry>
       <entry namest="c2" nameend="newCol5">
        <para>Function</para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry morerows="13">
        <para>-1EJ</para>
       </entry>
       <entry namest="c2" nameend="newCol5">
        <para>Return a number representing the computer and operating system upon which TECO is
         currently running. This value has the form 256m+n where m is a number representing the
         computer in use and n is a number representing the operating system that is running.
         Current values of m and n are: </para>
       </entry>
      </row>
      <row>
       <entry namest="c2" nameend="newCol3"><emphasis role="bold">Computer (m)</emphasis></entry>
       <entry namest="newCol4" nameend="newCol5"><emphasis role="bold">Operating System
         (n)</emphasis></entry>
      </row>
      <row>
       <entry>0</entry>
       <entry>PDP-11</entry>
       <entry>0</entry>
       <entry>RSX-11D</entry>
      </row>
      <row>
       <entry/>
       <entry>TOPS-10</entry>
       <entry>1</entry>
       <entry>RSX-11M</entry>
      </row>
      <row>
       <entry/>
       <entry/>
       <entry>2</entry>
       <entry>RSX-11S</entry>
      </row>
      <row>
       <entry/>
       <entry/>
       <entry>3</entry>
       <entry>IAS</entry>
      </row>
      <row>
       <entry/>
       <entry/>
       <entry>4</entry>
       <entry>RSTS/E</entry>
      </row>
      <row>
       <entry/>
       <entry/>
       <entry>5</entry>
       <entry>VAX/VMS (compatibility mode)</entry>
      </row>
      <row>
       <entry/>
       <entry/>
       <entry>6</entry>
       <entry>RSX-11M+</entry>
      </row>
      <row>
       <entry/>
       <entry/>
       <entry>7</entry>
       <entry>RT-11</entry>
      </row>
      <row>
       <entry>1</entry>
       <entry>PDP-8</entry>
       <entry>0</entry>
       <entry>OS/8</entry>
      </row>
      <row>
       <entry>2</entry>
       <entry>DEC-10</entry>
       <entry>0</entry>
       <entry>TOPS-10</entry>
      </row>
      <row>
       <entry>3</entry>
       <entry>DEC-20</entry>
       <entry>0</entry>
       <entry>TOPS-20</entry>
      </row>
      <row>
       <entry>4</entry>
       <entry>VAX-11</entry>
       <entry>0</entry>
       <entry>VAX/VMS (native mode)</entry>
      </row>
      <row>
       <entry>
        <para>0EJ</para>
       </entry>
       <entry namest="c2" nameend="newCol5">
        <para>Returns a value equal to your job number. On single-user systems, this is always a
         0.</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>1EJ</para>
       </entry>
       <entry namest="c2" nameend="newCol5">
        <para>Returns a value equal to your terminal keyboard number (the keyboard you detached from
         if you are running detached). On single-terminal systems, this is always a 0.</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>2EJ</para>
       </entry>
       <entry namest="c2" nameend="newCol5">
        <para>Returns a value equal to your operating system's user identification number. This may
         be called your UIC, PPN, Group, etc. under various operating systems. Consult the
         appendices for more information.</para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table><table xml:id="COM_TAB_SEI">
    <title>Setting Environment Information</title>
    <tgroup cols="2" align="left" colsep="1" rowsep="1">
     <colspec colname="c1"/>
     <colspec colname="c2"/>
     <thead>
      <row>
       <entry>
        <para>Command</para>
       </entry>
       <entry>
        <para>Function</para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <para>n,1EJ</para>
       </entry>
       <entry>
        <para>Set the terminal number to receive output. This will not affect terminal input. Your
         job will remain attached to, or detached from, your terminal, whichever it was before.
         Output will only occur if the specified terminal is ASSIGNed with a monitor ASSIGN command
         (you may ^C, issue that command and continue) and if your job has POKE privileges. This
         command also sets the terminal to be reattached if the set detach flag (64&amp;ET) is
         cleared. The reattaching operation requires [1,2] or JACCT privileges. [TECO-10
         only]</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>n,2EJ</para>
       </entry>
       <entry>
        <para>Sets your [p,pn] to n where n has the same format as the number returned by the 2EJ
         command. Issuance of this command requires the appropriate privileges. [TECO-10
         only]</para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para></sect1><sect1 xml:id="COM_MCF"><title>Mode Control Flags</title>
 <para>
 TECO has flags which control various aspects of its operation.
 You can find a flag's current setting by executing its command
 name without an argument; the current setting of the flag is
 returned as a value. A flag may be set to a specific value by
 executing its command name preceded by a numerical argument; the
 flag is set to the value of the argument.
 </para><para>
 The following table describes the commands that set and clear
 flags; <literal>&lt;flag></literal> represents any of the flags listed below.
 <table xml:id="COM_TAB_FMC"><title>Flag Manipulation Commands</title>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Command</para></entry><entry><para>Function</para></entry>
</row>
</thead>
 <tbody>
<row><entry><para><literal>&lt;flag></literal></para></entry><entry><para>Return value of flag.</para></entry></row>
 <row><entry><para>n<literal>&lt;flag></literal></para></entry><entry><para>Set value of flag to n.</para></entry></row>
 <row><entry><para>m,n<literal>&lt;flag></literal></para></entry><entry><para>
 In the flag, turn off those bits specified by m
 and turn on those bits specified by n.</para></entry></row>
 <row><entry><para>0,n<literal>&lt;flag></literal></para></entry><entry><para>
 Turn on the bits in the flag specified by n.</para></entry></row>
 <row><entry><para>m,0<literal>&lt;flag></literal></para></entry><entry><para>
 Turn off the bits in the flag specified by m.</para></entry></row>
 
</tbody>
</tgroup></table>
 </para><para>
 The flags have the following functions:
 <table xml:id="COM_TAB_MCF"><title>Mode Control Flags</title>
 <tgroup cols="3" align="left" colsep="1" rowsep="1">
     <colspec colname="c1"/>
     <colspec colname="c2" colwidth="50px"/>
     <colspec colname="newCol3"/>
     <thead>
      <row>
       <entry>
        <para>Command</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para>Function</para>
       </entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry morerows="10">
        <para>ED</para>
       </entry>
       <entry namest="c2" nameend="newCol3">The edit level flag, a bit-encoded word that controls
        TECO's behavior in various respects. Any combination of the individual bits may be set as
        the user sees fit. The bits have the following functions: </entry>
      </row>
      <row>
       <entry><emphasis role="bold">Bit</emphasis></entry>
       <entry><emphasis role="bold">Function</emphasis></entry>
      </row>
      <row>
       <entry>ED&amp;1</entry>
       <entry>Allow caret (^) in search strings. If this bit is clear, a caret (^) in a search
        string modifies the immediately following character to become a control character. When this
        bit is set, a caret in a search string is simply the literal character caret. If you are
        editing a file that contains many caret characters (e.g., a RUNOFF file with case control),
        you will want to set this bit. (For control of upper/lower case matching in search strings,
        see the ^X flag.)</entry>
      </row>
      <row>
       <entry>ED&amp;2</entry>
       <entry>Allow all Y and _ commands. If this bit is set, the Y (Yank) command and _ (underscore
        or backarrow) command work unconditionally as described earlier in the manual. If clear, the
        behavior of the Y and _ commands are modified as follows: If an output file is open and text
        exists in the text buffer, the Y or _ command will produce an error message and the command
        will be aborted leaving the text buffer unchanged. Note that if no output file is open the Y
        and _ commands act normally. Furthermore, if the text buffer is empty the Y command can be
        used to bring in a page of text whether or not an output file is open (HKY will always
        work). The _ command will succeed in bringing one page of text into an empty text buffer but
        will fail to bring in successive pages if an output file is open.</entry>
      </row>
      <row>
       <entry>ED&amp;4</entry>
       <entry>When this bit is clear, TECO will try to expand memory as much as it can in order to
        try to fit entire pages into memory when requested to do so. If this bit is set, arbitrary
        memory expansion will not occur. In that case, TECO will expand memory only on the A command
        and not on the Y, P, or N commands. This bit is always set in TECO-10 and has no
        significance in TECO-8 or in TECO-11 on RT-11.</entry>
      </row>
      <row>
       <entry>ED&amp;8</entry>
       <entry>Reserved for future use by TECO-8.</entry>
      </row>
      <row>
       <entry>ED&amp;16</entry>
       <entry>Allow failing searches to preserve dot. If this bit is set, then whenever a search
        fails, the original location of the text buffer pointer will be preserved. If this bit is
        clear, then failing searches (other than bounded searches) leave the text buffer pointer at
        pointer position 0 after they fail. [not in TECO-8]</entry>
      </row>
      <row>
       <entry>ED&amp;32</entry>
       <entry>
        <para>Enable immediate ESCape-sequence commands. If this bit is set, TECO will recognize an
         ESCape-sequence key pressed immediately after the prompting asterisk as an immediate
         command. See <xref linkend="CSE_IESC"/> for a description of immediate ESCape-sequence
         commands.</para>
        <para>If this bit is clear (the default case), TECO will treat an ESCape coming in
         immediately after the asterisk prompt as a <literal>&lt;DELIM></literal> That is, TECO will
         hear a discrete <literal>&lt;ESC></literal> character: an ESCape sequence will therefore be
         treated not as a unified command, but as a sequence of characters. [TECO-11 only]</para>
       </entry>
      </row>
      <row>
       <entry>ED&amp;64</entry>
       <entry>Only move dot by one on multiple occurrence searches. If this bit is clear, TECO
        treats nStext` exactly as n&lt;1Stext`>. That is, skip over the whole matched search string
        when proceeding to the nth search match. For example, if the text buffer contains only A's,
        the command 5SAA` will complete with dot equal to ten (10). If this bit is set, TECO
        increments dot by one each search match. In the above example, dot would become five (5).
        [TECO-11 only]</entry>
      </row>
      <row>
       <entry>ED&amp;128</entry>
       <entry>
        <para>Automatic refresh inhibit. If scroll mode is enabled (that is, if 7:W is non-zero),
         TECO normally refreshes the text buffer display just before printing its
        &star; prompt. Setting the 128 bit in ED inhibits this
         automatic refresh. (Inhibiting the automatic refresh may be useful when running over a slow
         terminal line; see also the ^W immediate command.) [TECO-11 only]</para>
       </entry>
      </row>
      <row>
       <entry namest="c2" nameend="newCol3">The initial value of ED&amp;1 is system dependent (See
        appendices). The initial value of the other bits in the ED flag is 0.</entry>
      </row>
      <row>
       <entry>
        <para>EE</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para>This flag is initially zero, and (unless the 8192 ET bit is set) TECO recognizes only
         the ESCape as its <literal>&lt;DELIM></literal> character from the terminal. If it is
         desired to use another character as an ESCape surrogate (as when working from a terminal
         lacking an ESCape key), the ASCII value of that other character may be set in the EE flag.
         Note that when an ESCape surrogate is set, the designated character (when typed at the
         terminal) is received by TECO as an ESCape &ndash; that character is no longer directly
         available at the keyboard. When an ESCape surrogate is active, an ESCape received by TECO
         echos as accent grave; when none is active, an ESCape received by TECO echos as dollar
         sign. This feature is provided for the benefit of newer terminals which lack an ESCape key.
         (8192ET and 96EE both set ` as ESCape surrogate. EE, however, can be used to designate a
         character other than accent grave.) [RSTS/E only]</para>
       </entry>
      </row>
      <row>
       <entry morerows="4">
        <para>EH</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para>The help level flag, which controls the printing of error messages and failed
         commands. (See also the / command.) </para>
       </entry>
      </row>
      <row>
       <entry><emphasis role="bold">Bits</emphasis></entry>
       <entry><emphasis role="bold">Function</emphasis></entry>
      </row>
      <row>
       <entry>EH&amp;3</entry>
       <entry>
        <para>The low two bits of EH (value range 0 through 3) control the printing of TECO error
         messages as follows (assuming the low two bits have value m):</para>
        <para>If m is equal to 1, error messages are output in abbreviated form ("?XXX"). If m is
         equal to 2, error messages are output in normal form ("?XXX Message"). If m is equal to 3,
         error messages are output in long or "War and Peace" form, that is, a paragraph of
         informative material is typed following the normal form of the error message. In TECO-11,
         m=3 is implemented only on VAX/VMS. (See section G.13 for a description of HELP facilities
         available on VAX/VMS.) In other TECO-11's, case m=3 is equivalent to m=2.</para>
       </entry>
      </row>
      <row>
       <entry>EH&amp;4</entry>
       <entry>If this bit of EH is set, the failing command is also output up to and including the
        failing character in the command followed by a question mark. (Just like TECO's response to
        the typing of a question mark immediately after an error.) This bit is not supported by
        TECO-10.</entry>
      </row>
      <row>
       <entry namest="c2" nameend="newCol3">
        <para>The initial value of the EH flag is 0 which is equivalent to a value of 2.</para>
       </entry>
      </row>
      <row>
       <entry>
        <para>EO</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para>Setting the value of the EO flag to n allows features that were peculiar to that
         version of TECO to work. [TECO-10 only]</para>
       </entry>
      </row>
      <row>
       <entry morerows="2">
        <para>ES</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para>The search verification flag, which controls the text typed out after searches.</para>
       </entry>
      </row>
      <row>
       <entry namest="c2" nameend="newCol3">
        <para>If n is equal to 0, nothing is typed out after searches. If n is -1, the current line
         is typed out when a successful search at top level is completed (i.e., a V command is done
         automatically). If n is between 1 and 31, the current line is typed out with a line feed
         immediately following the position of the pointer to identify its position. If n is between
         32 and 126, the current line is typed out with the ASCII character corresponding to the
         value of n immediately following the position of the pointer to identify its position. If
         you want to see more than one line of type out, use the form
         m&star;256+n. The n is the same as above. The m is the
         number of lines of view. For example, 3&star;256+^^! would
         give two lines on either side of the found line, and the found line with the character "!"
         at the pointer's position. The ES flag does not apply to searches executed inside
         iterations or macros; lines found inside iterations or macros are never typed out. [Not in
         TECO-8]</para>
       </entry>
      </row>
      <row>
       <entry namest="c2" nameend="newCol3">
        <para>The initial value of ES is 0.</para>
       </entry>
      </row>
      <row>
       <entry morerows="16">
        <para>ET</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para>The ET flag is a bit-encoded word controlling TECO's treatment of the terminal. Any
         combination of the individual bits may be set. The bits provide the following functions,
         when set: </para>
       </entry>
      </row>
      <row>
       <entry><emphasis role="bold">Bit</emphasis></entry>
       <entry><emphasis role="bold">Function</emphasis></entry>
      </row>
      <row>
       <entry>ET&amp;1</entry>
       <entry>
        <para>Type out in image mode. Setting this bit inhibits all of TECO's type out conversions.
         All characters are output to the terminal exactly as they appear in the buffer or ^A
         command. For example, the changing of control characters into the "caret/character" form,
         and the conversion of <literal>&lt;ESCAPE></literal> to ` (accent grave) or to $ (dollar
         sign) are suppressed. This mode is useful for driving displays. It should be used with
         caution, especially if you are talking to TECO over a dial-up line.</para>
       </entry>
      </row>
      <row>
       <entry>ET&amp;2</entry>
       <entry>
        <para>Process DELETEs and <literal>&lt;CTRL/U></literal>s in "scope" mode. Scope mode
         processing uses the cursor control features of CRT type terminals to handle character
         deletion by actually erasing characters from the screen.</para>
       </entry>
      </row>
      <row>
       <entry>ET&amp;4</entry>
       <entry>Read lower case. TECO normally converts all lower case alphabetics to upper case on
        input. Setting this bit causes lower case alphabetics to be input as lower case. TECO
        commands and file specifiers may be typed in either upper or lower case. For the purpose of
        searches, however, upper and lower case may be treated as different characters. (See ^X
        flag).</entry>
      </row>
      <row>
       <entry>ET&amp;8</entry>
       <entry>Read without echo for ^T commands. This allows data to be read by the ^T command
        without having the characters echo at the terminal. Normal command input to TECO will
        echo.</entry>
      </row>
      <row>
       <entry>ET&amp;16</entry>
       <entry>
        <para>Cancel <literal>&lt;CTRL/O></literal> on type out. Setting this bit will cancel any
         outstanding <literal>&lt;CTRL/O></literal> when the next type out occurs. After TECO has
         canceled the <literal>&lt;CTRL/O></literal>, it will automatically clear the bit.</para>
       </entry>
      </row>
      <row>
       <entry>ET&amp;32</entry>
       <entry>
        <para>Read with no wait. This enables the ^T command to test if a character is available at
         the user terminal. If a character has been typed, ^T returns the value of the character as
         always. If no character has been typed, ^T immediately returns a value of -1 and execution
         continues without waiting for a character.</para>
       </entry>
      </row>
      <row>
       <entry>ET&amp;64</entry>
       <entry>Detach flag (See appendices).</entry>
      </row>
      <row>
       <entry>ET&amp;128</entry>
       <entry>"Abort-on-error" bit. Initially set, when TECO starts up; cleared each time TECO
        issues its asterisk prompt. When this bit is set: 1&rpar; all informational messages are
        supressed, 2&rpar; any <literal>&lt;CTRL/C></literal> causes the immediate termination of
        TECO, and 3&rpar; any error causes the termination of TECO after the error message is
        printed.</entry>
      </row>
      <row>
       <entry>ET&amp;256</entry>
       <entry>If this bit is set, all lines output to the terminal are truncated to the terminal's
        width if needed. (RSTS/E, RSX-11, and VAX/VMS only. On VAX/VMS, this bit reflects and can
        change the state of the terminal characteristic WRAP/NOWRAP; TECO restores the terminal
        characteristic to its original state upon exit.)</entry>
      </row>
      <row>
       <entry>ET&amp;512</entry>
       <entry>
        <para>If this bit is set, the scope "WATCH" feature of TECO is present and your terminal is
         a scope type terminal. This bit is a read-only bit; its state cannot be altered. (See <xref
          linkend="COM_SCO"/>.)</para>
       </entry>
      </row>
      <row>
       <entry>ET&amp;1024</entry>
       <entry>
        <para>If this bit is set, the refresh scope "WATCH" feature of TECO is present and a refresh
         scope is available. This bit is a read-only bit; its state cannot be altered. (See <xref
          linkend="COM_SCO"/>.)</para>
       </entry>
      </row>
      <row>
       <entry>ET&amp;4096</entry>
       <entry>
        <para>This bit reflects and can change the state of the terminal characteristic (maintained
         by the operating system) recording whether the terminal is capable of handling eight-bit
         character codes. Upon entry to TECO, this bit reflects the characteristic as recorded with
         the operating system at that time. If you change this bit, the operating system is directed
         to change its recording of the characteristic to match.</para>
        <para>Because the data manipulated (edited) by TECO can consist of all 256 possible byte
         codes, the way data characters are displayed (typed out) at the terminal varies depending
         upon the setting of the 4096 ET bit.</para>
        <para>If the bit is clear (meaning that TECO understands your terminal to be 7-bit), valid
         DEC multi-national codes are typed out as <literal>&lt;xy></literal> (where xy is the
         corresponding LK201 keyboard compose sequence).</para>
        <para>If the bit is set (meaning that TECO understands your terminal to be 8-bit), valid DEC
         multi-national codes are typed out as themselves.</para>
        <para>In either case, unprintable or illegal codes in the 128 to 255 range are typed out as
         [ab] (where ab is the corresponding hexadecimal code). The scope watch feature (screen
         buffer display, controlled by the W commands) always uses the <literal>&lt;xy></literal>
         and [ab] notations.</para>
       </entry>
      </row>
      <row>
       <entry>ET&amp;8192</entry>
       <entry>
        <para>Accent grave as ESCape surrogate. [TECO-11 only]</para>
        <para>If this bit is set, TECO recognizes the ` (accent grave) character as an ESCAPE
         surrogate. That is, an ` character typed at the terminal will be recognized as a command
          <literal>&lt;DELIM></literal> character, and passed to TECO as an ESCape. (This
         interpretation applies only to <literal>&lt;DELIM></literal>s typed at the terminal; ESCape
         characters must still be used in macros and indirect files.) When an ESCape surrogate is
         set, an ESCape received by TECO echos as accent grave; when none is set, an ESCape received
         by TECO echos as dollar sign. This feature is provided for the benefit of certain newer
         terminals which lack an ESCape key. (See also the Introduction, and the EE flag.)</para>
       </entry>
      </row>
      <row>
       <entry>ET&amp;32768</entry>
       <entry>
        <para>If this bit is set and a <literal>&lt;CTRL/C></literal> is typed, the bit is turned
         off, but execution of the current command string is allowed to continue. This allows a TECO
         macro to detect typed <literal>&lt;CTRL/C></literal>s. In TECO-8, this bit is the 2048's
         bit rather than the 32768's bit.</para>
       </entry>
      </row>
      <row>
       <entry namest="c2" nameend="newCol3">The initial setting of ET is operating system dependent
        (See appendices). In addition, some of the ET bits are automatically turned off by certain
        error conditions.</entry>
      </row>
      <row>
       <entry morerows="2">EU</entry>
       <entry namest="c2" nameend="newCol3">
        <para>The upper/lower case flag.</para>
       </entry>
      </row>
      <row>
       <entry namest="c2" nameend="newCol3">
        <para>If n is -1, no case flagging of any type is performed on type out, lower case
         characters are output as lower case characters. If n is 0, lower case characters are
         flagged by outputting a ' (quote) before the lower case character and the lower case
         character is output in upper case; upper case characters are unchanged. If n is +1, upper
         case characters are flagged by outputting a ' (quote) before each one and then the upper
         case character is output; lower case characters are output as their upper case
         equivalents.</para>
       </entry>
      </row>
      <row>
       <entry namest="c2" nameend="newCol3">
        <para>The initial value of the EU flag is -1 if TECO can tell from the operating system that
         the user's terminal supports display of lower case characters; otherwise te initial value
         is 0. Consult the appendices for more details.</para>
       </entry>
      </row>
      <row>
       <entry morerows="1">EV</entry>
       <entry namest="c2" nameend="newCol3">
        <para>The edit verify flag is decoded just like the ES flag. Just before TECO prints its
         prompting&star;, the EV flag is checked. If it is
         non-zero the lines to be viewed are printed on the terminal.</para>
       </entry>
      </row>
      <row>
       <entry namest="c2" nameend="newCol3">
        <para>The initial value of the EV flag is 0. [TECO-11 only]</para>
       </entry>
      </row>
      <row>
       <entry morerows="3">
        <para>^X</para>
       </entry>
       <entry namest="c2" nameend="newCol3">
        <para>The search mode flag. [Not in TECO-8]</para>
       </entry>
      </row>
      <row>
       <entry namest="c2" nameend="newCol3">
        <para>If ^X is 0, the text argument in a search command will match text in the text buffer
         independent of case in either the search argument or the text buffer. The lower case
         alphabetics match the upper case alphabetics, and "`", "{", "|", "}", "~" match "@", "[",
         "\", "]", "^" respectively. In addition, DEC multinational characters having diacritical
         marks are regarded as matching the corresponding characters without diacritical
         marks.</para>
       </entry>
      </row>
      <row>
       <entry namest="c2" nameend="newCol3">
        <para>If ^X is -1, the search will succeed only if the text argument is identical to text in
         the text buffer. (This means that lower case does NOT match upper case, nor does a
         character having a diacritical mark match one without).</para>
       </entry>
      </row>
      <row>
       <entry namest="c2" nameend="newCol3">
        <para>The initial value of the ^X flag is 0. (For control of caret or uparrow treatment in
         search strings, see the ED&amp;1 bit above.)</para>
       </entry>
      </row>
     </tbody>
    </tgroup></table>
 </para></sect1><sect1 xml:id="COM_SCO"><title>Scope Commands</title>
 <para>
 The W command (scope "WATCH") is present in most implementations
 of TECO. There are two different variations of the W command.
 Neither, one, or both may be present. ET flag Bits 9 and 10
 indicate which variation(s) are configured and can be used.
 </para><sect2 xml:id="COM_SCO_VID"><title>Video Terminal Scope Commands</title>
 <para>
 If the VT support is present and your terminal is a video
 terminal (such as a VT05, VT52, or VT100), ET flag Bit 9 (value
 512) will be on.
 <table xml:id="COM_SCO_TAB_VTW"><title>Video Terminal Watch Commands</title>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Command</para></entry><entry><para>Function</para></entry>
</row>
</thead>
 <tbody>
<row><entry><para>-1W</para></entry><entry><para>Refresh the terminal's screen to show the contents of
 the text buffer.</para></entry></row>
 <row><entry><para>-nW</para></entry><entry><para>Tell the video terminal screen refresher that the top
 n-1 lines of the screen have been altered. The screen
 refresher will completely redraw the top n-1 lines of
 the screen upon the next -1W command.</para></entry></row>
 <row><entry><para>nW</para></entry><entry><para>Place the default cursor line at line n of the screen.
 The initial default cursor line is line 16. This
 command makes the window support forget the screen
 image and any special associated modes (SEEALL, MARK,
 HOLD).</para></entry></row>
 <row><entry><para>0W</para></entry><entry><para>Equivalent to "16W".</para></entry></row>
 <row><entry><para>W</para></entry><entry><para>Forget screen image and special scope modes.</para></entry></row>
 <row><entry><para>-1000W</para></entry><entry><para>Forget that output was done. Normally, if the user
 outputs to the terminal with a command such as T, n^T,
 or ^A, TECO will believe that the window needs
 updating, and upon the next -1W command, TECO will
 refresh the entire window display. Issuing the -1000W
 command informs TECO that the output command did not
 destroy the window.
 [TECO-11 only]</para></entry></row>
 
</tbody>
</tgroup></table>
 </para><para>
 The :W commands are used to interrogate and set (see m,n:W below)
 video terminal status information, as well as implement some of
 the more advanced features of the video terminal "WATCH"
 functions.
 <table xml:id="COM_SCO_TAB_VTS"><title>Video Terminal Status Commands</title>
 <tgroup cols="3" align="left" colsep="1" rowsep="1">
      <colspec colname="c1"/>
      <colspec colname="c2"/>
      <colspec colname="newCol3"/>
      <thead>
       <row>
        <entry>
         <para>Command</para>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para>Function</para>
        </entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry morerows="8">
         <para>0:W</para>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para>Return a number representing the type of scope in use as the editing terminal.
          Current values are:</para>
        </entry>
       </row>
       <row>
        <entry><emphasis role="bold">value</emphasis></entry>
        <entry><emphasis role="bold">scope type</emphasis></entry>
       </row>
       <row>
        <entry>0</entry>
        <entry>VT52</entry>
       </row>
       <row>
        <entry>1</entry>
        <entry>VT61 [TECO-10 only]</entry>
       </row>
       <row>
        <entry>2</entry>
        <entry>VT100 in VT52 mode</entry>
       </row>
       <row>
        <entry>4</entry>
        <entry>VT100 in ANSI mode</entry>
       </row>
       <row>
        <entry>6</entry>
        <entry>VT05</entry>
       </row>
       <row>
        <entry>8</entry>
        <entry>
         <para>VT102 in ANSI mod</para>
        </entry>
       </row>
       <row>
        <entry>10</entry>
        <entry>VK100 (GIGI)</entry>
       </row>
       <row>
        <entry>
         <para>:W</para>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para>Equivalent to 0:W</para>
        </entry>
       </row>
       <row>
        <entry>
         <para>1:W</para>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para>Return or set the horizontal size of the user's editing scope. This number represents
          the number of character positions available horizontally along the face of the
          scope.</para>
        </entry>
       </row>
       <row>
        <entry>
         <para/>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para>If this value is changed (see m,n:W below), the operating system is automatically
          informed of the terminal's new width setting, and the appropriate control sequence is
          issued to physically change the terminal's screen mode (80 versus 132 column mode) if
          needed.</para>
        </entry>
       </row>
       <row>
        <entry>
         <para>2:W</para>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para>Return or set the vertical size of the user's editing scope. This number represents
          the number of lines of text that can appear on the screen of the terminal. This number is
          affected by use of the m,7:W command (set scrolling region).</para>
        </entry>
       </row>
       <row>
        <entry>
         <para>3:W</para>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para>Return or set SEEALL mode. 0 represents off and -1 represents on. In SEEALL mode, a
          visible indication is shown in the window for every character, including characters that
          normally don't print.</para>
        </entry>
       </row>
       <row>
        <entry>
         <para>4:W</para>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para>Return or set "mark" status of window support. 0 means that no mark has been set. A
          value of n means that a mark has been set at buffer ("dot") position n-1. This status is
          used by software that uses the window support and by the support itself in the case of
          scopes that support reverse video.</para>
        </entry>
       </row>
       <row>
        <entry>
         <para>5:W</para>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para>Return or set the hold mode indicator. 0 means off, -1 means hold whole screen, and a
          positive value, n, means hold all but top and bottom n lines. If hold mode is on, then
          scrolling is inhibited until the cursor is about to run off either end of the screen. This
          makes the window display more palatable on terminals on a slow line. If hold mode is on,
          the window support will scroll the window as necessary in an attempt to keep the cursor
          centered.</para>
        </entry>
       </row>
       <row>
        <entry>
         <para>6:W</para>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para>Returns buffer pointer position of character that was in the upper left hand corner
          of the window as of the last -1W command.</para>
        </entry>
       </row>
       <row>
        <entry>
         <para>7:W</para>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para>Return or set the number of lines in the scrolling (command dialogue) portion of the
          screen. If n is zero, then split screen scrolling is disabled. When split screen scrolling
          is enabled, n lines (as specified) are reserved at the bottom of the screen to scroll the
          terminal interaction. The remainder of the screen is used as a display window into the
          text buffer, and is automatically updated by TECO immediately before each command prompt.
          This feature functions only on terminals capable of split screen scrolling, such as
          members of the VT100 and VT200 families.</para>
        </entry>
       </row>
       <row>
        <entry>
         <para/>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para>The value of n must be greater than 1, and scope height minus n must be greater than
          9.</para>
        </entry>
       </row>
       <row>
        <entry>
         <para/>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para>Whenever the scrolling region's size is modified (that is, whenever an m,7:W command
          is executed), TECO alters the scope's height (2:W) accordingly. For example, if 2:W is
          currently returning a value of 24, then after a 5,7:W command 2:W will return a value of
          19. Executing a 0,7:W will restore 2:W to 24.</para>
        </entry>
       </row>
       <row>
        <entry>
         <para>m,n:W</para>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para>Sets the entity represented by n:W to m and returns a value. If the new setting has
          been accepted, the returned value is m. Elsewise, the returned value is either the old
          value associated with n:W or whatever new setting was actually set. In all cases, the
          returned value reflects the new current setting. Specific operating systems may put
          restrictions on the valid values for m.</para>
        </entry>
       </row>
       <row>
        <entry>
         <para/>
        </entry>
        <entry namest="c2" nameend="newCol3">
         <para>Note that each m,n:W command returns a value, even if your only intent is to set
          something. Good programming practice suggests following any command which returns a value
          with <literal>&lt;DELIM></literal> or ^[ if you don't intend that value to be passed to
          the following command.</para>
        </entry>
       </row>
      </tbody>
     </tgroup></table>
 </para></sect2><sect2 xml:id="COM_SCO_REF"><title>Refresh Scope Commands</title>
 <para>
 If refresh scope support is present and a refresh scope is
 available (such as a VS60 or a VR12), bit value 1024 of the ET
 flag will be on.
 <table xml:id="COM_SCO_TAB_REF"><title>Refresh Scope Watch Commands</title>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Command</para></entry><entry><para>Function</para></entry>
</row>
</thead>
 <tbody>
<row><entry><para>W</para></entry><entry><para>Update the refresh scope screen to reflect the contents
 of the text buffer surrounding the text pointer
 ("dot").</para></entry></row>
 <row><entry><para>0W</para></entry><entry><para>Turn off the refresh scope display.</para></entry></row>
 <row><entry><para>nW</para></entry><entry><para>Set the number of lines to be displayed around the text
 pointer to n.</para></entry></row>
 
</tbody>
</tgroup></table>
 </para></sect2></sect1><sect1 xml:id="COM_AID"><title>Programming Aids</title>
 <para>
 In addition to the command string editing capabilities described
 in <xref linkend="CSE"/>, TECO includes various features to facilitate
 programming. These are described in the following sections.
 </para><sect2 xml:id="COM_AID_TXF"><title>Text Formatting</title>
 <para>
 The characters carriage return, line feed, and space are ignored
 in command strings, except when they appear as part of a text
 argument. Numeric values are not affected. (Inserting a space
 between digits within a digit string may cause unpredictable
 results). These characters may be inserted between any two TECO
 commands to lend clarity to a long command string. The carriage
 return/line feed combination is particularly useful for typing
 command strings which are too long to fit on a single line.
 </para><para>
 If the character form feed is encountered in a command string and
 it is not part of a text argument, a form feed is output to the
 terminal. This can be used to format terminal output. On
 TECO-10, execution of the form feed command will clear the screen
 if TECO is in scope command string editing mode (2&amp;ET on).
 </para></sect2><sect2 xml:id="COM_AID_COM"><title>Comments</title>
 <para>
 One of the most powerful features of TECO is its ability to store
 very long command strings so that a given sequence of commands
 may be executed whenever needed. Long command strings may be
 thought of as editing programs and, like any other type of
 program, they should be documented by means of comments.
 </para><para>
 Comments may be inserted between any two commands by using a tag
 construction of the form:
 </para>
   <screen>!THIS IS A COMMENT!</screen><para>
 Comments may contain any number of characters and any characters
 except the special characters. Thus a long TECO macro might look
 like:
 <informaltable>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <tbody>
<row><entry><para/></entry><entry><para>TECO commands !This comment describes line 1!</para></entry></row>
 <row><entry><para/></entry><entry><para>TECO commands !This comment describes line 2!</para></entry></row>
 <row><entry><para/></entry><entry><para>more commands</para></entry></row>
 <row><entry><para/></entry><entry><para>more commands !end of comment string!</para></entry></row>
 
</tbody>
</tgroup></informaltable>
 </para><para>
 Do not use <literal>&lt;TAB></literal> characters to format long command strings! Only
 <literal>&lt;space></literal>, <literal>&lt;CR></literal>, and <literal>&lt;LF></literal> can be used to
 format command strings since <literal>&lt;TAB></literal> is an insertion command.
 </para><para>
 Good TECO code is well structured and adequately commented.
 Unfortunately, massive comments in a TECO macro tend to slow
 execution, especially if they appear within text scanned by GOTOs
 or unsatisfied conditionals. Unless speed is not a goal, it is
 common practice in larger TECO programs to strip out comments
 before loading up TECO macros. Thus the TECO program can be
 adequately commented, yet still run efficiently.
 </para><para>
 A large TECO program can start by placing a comment stripper in a
 Q-register, say Q-register C. Then it can successively put
 subroutines (macro text) into the text buffer, do an MC, and load
 the appropriate Q-register with the resulting text buffer, until
 all the subroutines have been loaded. Finally, Q-register C can
 be zeroed and the program started.
 </para><para>
 In order for you to strip the comments without losing essential
 tags, you must make a convention for the format of your comments
 so that your comment stripper can distinguish them from tags.
 There are two common conventions. In one, the first character in
 every comment after the initial ! is some distinctive character,
 such as&star;. In the other, all tags start in the left margin and
 all comments are embedded within the text. Any large comment
 that wants to be on a line by itself starts with a <literal>&lt;space></literal> before
 the !. Both methods allow for readable code and easy comment
 stripping.
 </para></sect2><sect2 xml:id="COM_AID_MES"><title>Messages</title>
 <para>
 The <literal>&lt;CTRL/A></literal> command may be used to print out a statement at any
 point during the execution of a command string. The <literal>&lt;CTRL/A></literal>
 command has the general form:
 </para>
   <screen>^Atext&lt;CTRL/A></screen><para> or </para>
   <screen>@^A/text/</screen><para>
 The first ^A is the actual command, which may be entered by
 striking the control key and the A key simultaneously or by
 typing a caret (uparrow) followed by an A character. The second
 <literal>&lt;CTRL/A></literal> character of the first form shown is the command
 terminator, which must be entered by typing the control key and
 the A key simultaneously. In the second form, the second
 occurrence of the delimiting character (shown as slash in the
 example) terminates the message. Upon execution, this command
 causes TECO to print the specified message at the terminal.
 </para><para>
 The ^Amessage<literal>&lt;CTRL/A></literal> command is particularly useful when it
 precedes a command whose numeric argument contains ^T or ^F
 characters. The message may contain instructions notifying the
 user as to what sort of input is required.
 </para></sect2><sect2 xml:id="COM_AID_TRC"><title>Tracing</title>
 <para>
 A question mark entered betweeen any two commands in a command
 string causes TECO to print all subsequent commands at the
 terminal as they are executed. Commands will be printed as they
 are executed until another question mark character is encountered
 or the command string terminates.
 </para></sect2><sect2 xml:id="COM_AID_CON"><title>Convenience Characters</title>
 <para>
 In addition to the characters mentioned in <xref linkend="COM_AID_TXF"/>, there
 are several characters which have no special meaning to TECO but
 which may be used to help format your TECO programs and command
 strings. Judicious use of these commands will make your program
 easier to read and maintain. These characters are described in
 the table below:
 <table xml:id="COM_AID_TAB_CON"><title>Convenience Characters</title>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Character</para></entry><entry><para>Meaning</para></entry>
</row>
</thead>
 <tbody>
<row><entry><para><literal>&lt;NULL></literal></para></entry><entry><para>A null (ASCII 0) encountered as a TECO
 command will be ignored. Numeric values are
 not affected. A null read in from an input
 file will be discarded (except under RSX-11
 and VAX/VMS). A null typed in from a
 terminal will be ignored.</para></entry></row>
 <row><entry><para><literal>&lt;ESCAPE></literal></para></entry><entry><para>An ESCape that is executed as a TECO command
 (as distinct from an immediate action command
 or an ESCape that is part of the syntax of
 some other TECO command) is ignored by TECO.
 However, any pending numeric values are
 discarded. This command is useful for
 discarding the value returned from a command
 (such as n%q or m,n:W) when you don't want
 that value to affect execution of the
 following command.</para></entry></row>
 <row><entry><para>^[</para></entry><entry><para>Same as <literal>&lt;ESCAPE></literal>. Like any other TECO
 command that is a control character, ESCape
 may be entered in up-arrow mode. Sometimes
 easier to type, ^[ is also useful on systems
 whose line-printer spoolers do not visibly
 print the ESCape character.</para></entry></row>
 <row><entry><para/></entry><entry><para>Any pending numeric values are discarded.
 This command is useful for discarding the
 value returned from a command (such as n%q or
 m,n:W) when you don't want that value to
 affect execution of the following command.</para></entry></row>
 <row><entry><para><literal>&lt;ALTMODE></literal></para></entry><entry><para>Some older terminals may have no ESCape key,
 but instead a key labelled ALTMODE or PREFIX
 which sends TECO a character whose ASCII
 value is 175 or 176. In such a case, TECO
 will treat these characters as if they were
 typed in as an ESCape (octal 33), provided
 lower to upper case conversion is enabled.</para></entry></row>
 <row><entry><para>$</para></entry><entry><para>(dollar sign)
 Same as <literal>&lt;ESCAPE></literal>, but as a command only, not
 as a string terminator.
 [TECO-10 only]</para></entry></row>
 
</tbody>
</tgroup></table>
 </para><para>
 Note that <literal>&lt;TAB></literal> and <literal>&lt;FORM FEED></literal> are valid TECO commands
 and must not be used as aids to formatting TECO programs.
 </para></sect2><sect2 xml:id="COM_AID_MEM"><title>Memory Expansion</title>
 <para>
 The nEC command can be used to make TECO reclaim lost space after
 it had expanded memory usage. nEC tells TECO to expand or
 contract until it uses nK words of memory. If this is not
 possible, then TECO's memory usage does not change. The 0EC
 command tells TECO to shrink back to its original size (use the
 least amount of memory possible).
 [TECO-10 only]
 </para></sect2><sect2 xml:id="COM_AID_CAS"><title>Case Control</title>
 <para>
 The <literal>&lt;CTRL/V></literal> and <literal>&lt;CTRL/W></literal> TECO commands are used to
 specify automatic case control for alphabetic characters typed into
 strings.
 <table xml:id="COM_AID_TAB_CAS"><title>Case Control Characters</title>
 <tgroup cols="2" align="left" colsep="1" rowsep="1">
<colspec colname="c1"/>
<colspec colname="c2"/>

 <thead>
<row>
<entry><para>Character</para></entry><entry><para>Meaning</para></entry>
</row>
</thead>
 <tbody>
<row><entry><para>^V</para></entry><entry><para>
 <literal>&lt;CTRL/V></literal> puts TECO into lower case conversion mode. In
 this mode, all alphabetic characters in string
 arguments are automatically changed to lower case.
 This mode can be overridden by explicit case control
 within the search string. This command makes all
 strings behave as if they began with a ^V^V.
 [TECO-10 only]</para></entry></row>
 <row><entry><para>^W</para></entry><entry><para>
 <literal>&lt;CTRL/W></literal> puts TECO into upper case conversion mode. In
 this mode, all alphabetic characters in string
 arguments are automatically changed to upper case.
 This mode can be overriden by explicit case control
 within the search string. This command makes all
 strings behave as if they began with ^W^W.
 [TECO-10 only]</para></entry></row>
 <row><entry><para>0^V</para></entry><entry><para>Returns TECO to its original mode. No special case
 conversion occurs within strings except those case
 conversions that are explicitly specified by ^V and ^W
 string build constructs located within the string.
 [TECO-10 only]</para></entry></row>
 <row><entry><para>0^W</para></entry><entry><para>Same as 0^V.
 [TECO-10 only]</para></entry></row>
 
</tbody>
</tgroup></table>
 </para></sect2></sect1><sect1 xml:id="COM_MLP"><title>Manipulating Large Pages</title>
 <para>
 TECO is designed to operate most efficiently when editing files
 that contain no more than several thousand characters per page.
 (TECO storage includes Q-register storage and buffer space. The
 size of the text storage area is dynamic and depends on the
 amount of available memory.) If any page of an input file is too
 large to fit in the text area, the TECO input commands will
 terminate reading that page into memory when the first line feed
 is encountered after a point that the buffer is 3/4 full. (See
 appendices for details.) You can make room by positioning the
 pointer past a section of text at the beginning of the buffer and
 moving that section out of the buffer with the commands:
 </para>
  <screen>0,.PW0,.K</screen><para>
 It is sometimes advantageous to restrict the amount of the file
 that is present in the buffer. For example, each insert and
 delete command must move the entire text that is beyond the point
 of insertion or deletion. An operation that does many small
 inserts or deletes may therefore run extremely slowly if the text
 buffer is large. Such an operation can be sped up substantially
 by reading the input file with n:A commands and explicitly
 writing the processed text.
 </para></sect1><sect1 xml:id="COM_TEC"><title>Techniques and Examples</title>
 <para>
 The most elementary TECO application, described in <xref linkend="BAS"/> of
 this manual, is creating and editing ASCII files on-line. The
 user enters short command strings, often consisting of a single
 command, and proceeds from task to task until the file is
 completely edited.
 </para><para>
 Since every editing job is simply a long sequence of TECO
 commands, you may accomplish an entire job with one long command
 string made up of all the short command strings placed end to end
 with the intervening double <literal>&lt;DELIM></literal> characters removed. A long
 command string that performs a certain editing task can be
 considered a TECO "editing program". Editing programs may be
 written (using TECO) and stored in the same manner as any other
 ASCII file. Whenever the program is needed, it may be read into
 the buffer as text, stored in a Q-register, and executed by an Mq
 command.
 </para><para>
 For more complex editing jobs, you may want to write and maintain
 a collection of specialized "editing subroutines." TECO
 subroutines can perform such elementary functions as replacing
 every occurrence of two or more consecutive spaces with a
 tabulation character, for example, or ensuring that words are not
 hyphenated across a page boundary. When an editing problem
 arises, you can load the right combination of subroutines into
 various Q-registers, augment them with additional commands if
 necessary, and call them by a "mainline" command string.
 </para><para>
 Editing subroutines are essentially macros; that is, sequences
 of commands which perform commonly required editing functions.
 The most powerful application of TECO is the creation and use of
 a macro library. As you perform an editing job, look for
 sequences of operations which might be required in future editing
 assignments. Load all of the TECO commands required to perform
 such an operation into a Q-register. When the job is finished,
 write the contents of the Q-register onto an output file (via the
 buffer) and save it in the macro library. The nMq and m,nMq
 commands, which were designed to facilitate use of macros, permit
 run-time numeric arguments to be passed to a macro.
 </para><para> TECO macros can preserve the user's radix, flag values, etc. By using the Q-register
   push-down list, the macro can save and then restore values and/or text. For example: <example
    xml:id="COM_TEC_EXA1">
    <title>Saving and Restoring values and/or text</title>
    <programlisting>   [0 [1 [2     ! Save contents of Q-registers 0, 1 and 2 !
   +0U0         ! Put any calling argument into Q-register 0 !
   10U1         ! Put a 10 (if radix is decimal) or 8 (if radix is
                  octal) into Q-register 1 !
   ^D           ! Ensure that the current radix is now decimal !
   EUU2         ! Save the case flagging flag !
   -1EU         ! Ensure no case flagging !
   Q0"E 3U0 '   ! Default calling argument to 3 !
    &vellip;
   Q2EU         ! Restore the case flagging flag !
   10-Q1"N ^O ' ! Restore radix as octal if needed !
   ]2 ]1 ]0     ! Restore contents of Q-registers 2, 1, and 0 !</programlisting>
   </example></para><para>
 The EI command is particularly useful for executing macros from a
 library, since with it they may be read without disturbing the
 current input file. This makes it unnecessary to plan in advance
 which macros might be needed; it also saves Q-register storage
 space. You can retrieve two kinds of TECO command files with an
 EI command: a file containing a TECO command that loads the
 macro into a Q-register for later use, or a file containing just
 the macro (which must be retrieved with EI each time it is used).
 </para><para>
 The following examples are intended to illustrate some of the
 techniques discussed above. It would not be practical to include
 examples of the use of every TECO command, since most of the
 commands apply to many diverse situations. Instead, you are
 encouraged to experiment with the individual commands on scratch
 files.
 <example xml:id="COM_TEC_EXA2"><title>Splitting, Merging, And Rearranging Files</title>
 <!-- <example_attributes>(multipage) -->
 <para>
 Assume that there is a file named PROG.DAT on the system disk and
 that this file contains data in the following form:
 </para><para>
 AB <literal>&lt;FF></literal> CD <literal>&lt;FF></literal> EF <literal>&lt;FF></literal> GH <literal>&lt;FF></literal> IJ <literal>&lt;FF></literal> KL <literal>&lt;FF></literal> MN <literal>&lt;FF></literal> OP
 </para><para>
 where each of the letters A, B, C etc., represents 20 lines of
 text and <literal>&lt;FF></literal> represents a form feed character. The user intends
 to rearrange the file so that it appears in the following format:
 </para><para>
 AOB <literal>&lt;FF></literal> D <literal>&lt;FF></literal> MN <literal>&lt;FF></literal> EF <literal>&lt;FF></literal> ICJ <literal>&lt;FF></literal> KL <literal>&lt;FF></literal> P <literal>&lt;FF></literal> GH
 </para><para> The following sequence of commands will achieve this rearrangement. (Search command arguments
     are not listed explicitly.)
     <programlisting>
                   Start TECO.
&star;2ED``            Allow all Y commands.
&star;EBPROG.DAT`Y``   Specify input file and get first page.
&star;NC``             Search for a character string in C, writing A
                   and B on the output file.
&star;J20X1``          Save all of C in Q-register 1.
&star;20K``            Delete C from the buffer.
&star;NG``             Search for a character string in G, writing
                   D, E, and F on the output file.
&star;HX2``            Save G and H in Q-register 2.
&star;Y``              Delete GH from the buffer and read IJ.
&star;20L``            Move the pointer to the beginning of J.
&star;G1``             Insert C, which was stored in Q-register 1.
&star;NM``             Search for a character string in M, writing
                   ICJ and KL on the output file.
&star;HX1``            Save MN in Q-register 1 (the previous
                   contents is overwritten).
&star;Y``              Delete MN and read OP
&star;J20X3``          Save all of O in Q-register 3.
&star;20K``            Delete O from the buffer.
&star;PWHK``           Write P onto the output file, appending a
                   form feed, and clear the text buffer.
&star;G2``             Bring GH into the buffer from Q-register 2.
&star;HPEF``           Write GH on the output file and close it.
&star;EBPROG.DAT`Y``   Open the partially revised file.
&star;20L``            Move the pointer to the beginning of B.
&star;G3``             Insert all of O from Q-register 3.
&star;ND``             Search for a character string in D writing
                   AOB on the output file.
&star;PWHK``           Write D on the output file and clear buffer.
&star;G1``             Bring all of MN from Q-register 1 into the
                   buffer.
&star;EX``             Write MN onto the output file, then close the
                   file and exit.
 </programlisting>
    </para><para>
 At this point the file has been rearranged in the desired format.
 Of course, this rearrangement could have been accomplished in
 fewer steps if the commands listed above had been combined into
 longer command strings. Note that the asterisks shown at the
 left margin in this example are generated by TECO, and not typed
 by the user.
 </para><para>
 Assume, now, that the same input file, containing data in the
 form:
 </para><para>
 AB <literal>&lt;FF></literal> CD <literal>&lt;FF></literal> EF <literal>&lt;FF></literal> ... <literal>&lt;FF></literal> OP
 </para><para>
 is to be split into two separate files, with the first file
 containing AB <literal>&lt;FF></literal> CD and the second file containing KL <literal>&lt;FF></literal> M,
 while the rest of the data is to be discarded. The following
 commands could be used to achieve this rearrangement:
 </para><para>
 <programlisting>
                   Start TECO.
&star;2ED``            Allow all Y commands.
&star;ERFILE`EWFILE1`` Open the input file and the first output
                   file.
&star;Y``              Read AB into the buffer.
&star;P``              Write AB <literal>&lt;FF></literal> onto the output file and read
                   CD into the buffer.
&star;HPEF``           Write CD onto the output file (without
                   appending a form feed), and close the first
                   output file.
&star;_K``             Search for a character string in K. After
                   this command has been executed, the buffer
                   will contain KL. No output is generated.
&star;EWFILE2`P``      Open the second output file and write KL onto
                   it. Read MN into the buffer.
&star;20L0,.P``        Move the pointer to the end of M, then write
                   M onto the output file.
&star;EF``             Close the output file.
&star;HKEX``           Clear the buffer and exit.
 </programlisting>
 </para><para>
 As a final example of file manipulation techniques, assume that
 there are two files. One file is MATH.ONE, which contains
 information in the form:
 </para><para>
 AB <literal>&lt;FF></literal> CD <literal>&lt;FF></literal> EF <literal>&lt;FF></literal> GH <literal>&lt;FF></literal> IJ <literal>&lt;FF></literal> KL
 </para><para>
 and the other is MATH.TWO, which contains:
 </para><para>
 MN <literal>&lt;FF></literal> OP <literal>&lt;FF></literal> QR
 </para><para>
 If both of these files are stored on DK1, the following sequence
 of commands may be used to merge the two files into a single
 file, MATH.NEW, which contains all of MATH.TWO followed by the
 latter half of file MATH.ONE in the following format:
 </para><para> MN <literal>&lt;FF></literal> OP <literal>&lt;FF></literal> QR <literal>&lt;FF></literal> GH
      <literal>&lt;FF></literal> IJ <literal>&lt;FF></literal> KL
     <programlisting>
                   Start TECO.
&star;2ED``            Allow all Y commands.
&star;ERDK1:MATH.TWO`` Open the first input file.
&star;EWMATH.NEW``     Open the output file on the default device.
&star;Y``              Read MN into the text buffer.
&star;NR``             Search for a character string in R, writing
                   MN and OP onto the output file.
&star;PW``             Write QR onto the output file, appending a
                   form feed.
&star;ERDK1:MATH.ONE`` Open the second input file.
&star;HKY``            Read AB into the buffer. QR is over-written.
&star;_G``             Search for a character string in G, deleting
                   AB, CD, and EF, leaving GH in the buffer.
&star;NK``             Search for a character string in K, writing
                   GH and IJ on the output file, leaving KL in
                   the buffer
&star;HPEFHKEX``       Write KL onto the output file (without
                   appending a form feed) and close the file,
                   then exit.
 </programlisting>
    </para></example>
 </para><para>
 <example xml:id="COM_TEC_EXA3"><title>Alphabetizing by Interchange Sort</title>
 <!-- <example_attributes>(multipage) -->
 <para>
 Assume that TECO is running and that the buffer contains many
 short lines of text beginning with an alphabetic character at the
 left margin (i.e., immediately following a line feed). The lines
 might consist of names in a roster, for example, or entries in an
 index. The following command string will rearrange the lines
 into rough alphabetical order, grouping all lines which begin
 with the character "A" at the beginning of the page, followed by
 all lines with "B", and so on. Note that the algorithm could be
 extended to place the entries in strict alphabetical order by
 having it loop back to perform the same sorting operation on
 successive characters in each line.
 <programlisting>
 !START! J 0AUA                !Load first character of first line
                                into Q-register A !
 !CONT! L 0AUB                 !Load first character of next line
                                into Q-register B !
 QA-QB"G XA K -L GA 1UZ '      !If A&amp;gt;B, switch the lines and set a
                                flag (Q-register Z) !
 QBUA                          !Load B into A !
 L Z-."G -L @O/CONT/ '         !Loop back if there is another line
                                in the buffer !
 QZ"G 0UZ @O/START/ '          !Repeat if a switch was made on the
                                last pass !
 </programlisting>
 </para><para>
 The same algorithm can be coded in a more structured way as
 follows:
 <programlisting>
 0UZ                           !clear repeat flag!
 &amp;lt;J 0AUA L                     !Load first character of first line
                                into Q-register A !
 &amp;lt;0AUB                         !Load first character of next line
                                into Q-register B !
 QA-QB"G XA K -L GA -1UZ '     !If A&amp;gt;B, switch the lines and set a
                                flag !
 QBUA                          !Load B into A !
 L .-Z;&amp;gt;                       !Loop back if there is another line
                                in the buffer !
 QZ;&amp;gt;                          !Repeat if a switch was made on the
                                last pass !
 </programlisting>
 </para><para>
 This example is a bit shorter and does not use any GOTOs. It
 will also run somewhat faster.
 </para></example>
</para></sect1></chapter>
